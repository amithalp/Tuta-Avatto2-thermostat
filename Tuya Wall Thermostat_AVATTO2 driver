/**
 * amithalp - Things to do - thermostatOperatingState - check what to present (ON/OFF or Idle/Heat) -DONE
 *              - invert relay option - parameter 7 on the thermostat menu allows to invert from NC to NO. Need to make the driver show the current value in the device page (NO or NC) and allow changing from the device page - DONE
 *              - Check how allow changing the setpoint temp using the dashboard tile with 0.5 C increment - DONE
 *              - Fix the driver so when you increase setpoint value from the thermostat itself it does not send the value 30 but the correct value - COULD NOT REPLICATE
 *              - Check why brighness become low after a few seconds even if you set it to high
 *              - invert relay option - what happens when doing factory reset and initializa - FACTORY RESET WIL CHANGE THE RELAY STATE TO NO. INITIALIZE WILL NOT CHANGE RELAY STATE



 *  Tuya Wall Thermostat driver for Hubitat Elevation
 *
 *  https://community.hubitat.com/t/release-tuya-wall-mount-thermostat-water-electric-floor-heating-zigbee-driver/87050 
 *
 *    Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *    in compliance with the License. You may obtain a copy of the License at:
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *    on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *    for the specific language governing permissions and limitations under the License.
 * 
 *  Credits: Jaewon Park, iquix and many others
 * 
 * ver. 1.0.0 2022-01-09 kkossev  - Inital version
 * ver. 1.0.1 2022-01-09 kkossev  - modelGroupPreference working OK
 * ver. 1.0.2 2022-01-09 kkossev  - MOES group heatingSetpoint and setpointReceiveCheck() bug fixes
 * ver. 1.0.3 2022-01-10 kkossev  - resending heatingSetpoint max 3 retries; heatSetpoint rounding up/down; incorrect temperature reading check; min and max values for heatingSetpoint
 * ver. 1.0.4 2022-01-11 kkossev  - reads temp. calibration for AVATTO, patch: temperatures > 50 are divided by 10!; AVATO parameters decoding; added BEOK model
 * ver. 1.0.5 2022-01-15 kkossev  - 2E+1 bug fixed; added rxCounter, txCounter, duplicateCounter; ChildLock control; if boost (emergency) mode was on, then auto() heat() off() commands cancel it;
 *                                  BRT-100 thermostatOperatingState changes on valve report; AVATTO/MOES switching from off mode to auto/heat modes fix; command 'controlMode' is now removed.
 * ver. 1.0.6 2022-01-16 kkossev  - debug/trace commands fixes
 * ver. 1.0.7 2022-03-21 kkossev  - added childLock attribute and events; checkDriverVersion(); removed 'Switch' capability and events; enabled 'auto' mode for all thermostat types.
 * ver. 1.0.8 2022-04-03 kkossev  - added tempCalibration; hysteresis; minTemp and maxTemp for AVATTO and BRT-100; added Battery capability for BRT-100
 * ver. 1.2.1 2022-04-05 kkossev  - BRT-100 basic cluster warning supressed; tempCalibration, maxTemp, minTemp fixes; added Battery capability; 'Changed from device Web UI' desctiption in off() and heat() events.
 * ver. 1.2.2 2022-09-04 kkossev  - AVATTO additional DP logging; removed Calibration command (now is as Preference parameter); replaced Initialize capability w/ custom command; degrees symbol in temp. unit;
 *                                  Refresh command wakes up the display';  Google Home compatibility
 * ver. 1.2.3 2022-09-05 kkossev  - added FactoryReset command (experimental, change Boolean debug = true); added AVATTO programMode preference; 
 * ver. 1.2.4 2022-09-28 kkossev  - _TZE200_2ekuz3dz fingerprint corrected
 * ver. 1.2.5 2022-10-08 kkossev  - BEOK: added sound on/off, tempCalibration, hysteresis, tempCeiling, setBrightness, 0.5 degrees heatingSetpoint (BEOK only); bug fixes for BEOK: Child lock, thermostatMode, operatingState
 * ver. 1.2.6 2022-10-16 kkossev  - BEOK: time sync workaround; BEOK: temperature scientific representation bug fix; parameters number/decimal fixes; brightness and maxTemp bug fixes; heatingTemp is always rounded to 0.5; cool() does not switch the thermostat off anymore
 * ver. 1.2.7 2022-11-05 kkossev  - BEOK: added frostProtection; BRT-100: tempCalibration bug fix; reversed heat and auto modes for MOES dp=3; hysteresis is hidden for BRT-100; maxTemp lower limit set to 15; dp3 is ignored from MOES/BSEED if in off mode
 *                                  supressed dp=9 BRT-100 unknown function warning; 
 * ver. 1.2.8 2022-11-27 kkossev  - added 'brightness' attribute; removed MODEL3; dp=3 refactored; presence function bug fix; added resetStats command; refactored stats; faster sending of Zigbee commands; time is synced every hour for BEOK;
 *                                  modeReceiveCheck() and setpointReceiveCheck() refactored; 
 * ver. 1.2.9 2022-12-05 kkossev  - bugfix: 'supportedThermostatFanModes' and 'supportedThermostatModes' proper JSON formatting; homeKitCompatibility option
 * ver. 1.2.10 2023-01-08 kkossev  - bugfix: AVATTO thermostat can not be switched off from HE dashboard;
 * ver. 1.2.11 2023-01-14 kkossev  - bugfix: BEOK setBrightness retry
 * ver. 1.3.0  2023-06-03 kkossev  - added sensorSelection; replaced Presence w/ Health Status; added ping() and rtt; added '--- Select ---' default value for the sensorSelection command; added sensorSelection as attribute
 * ver. 1.3.1  2023-10-29 kkossev  - (dev. branch) - added 'HY369' group (TS0601 _TZE200_ckud7u2l); add state.deviceProfile
 * ver. 1.3.2  2023-11-16 kkossev  - (dev. branch) - added TS0601 _TZE200_bvrlmajk Avatto TRV07 ; added Immax Neo Lite TRV 07732L TS0601 _TZE200_rufdtfyv as HY367; 
 * ver. 1.3.3  2023-11-16 vnistor  - (dev. branch) - added modes, valve, childLock, windowOpen, windowOpenDetection, thermostatOperatingState to TS0601 _TZE200_bvrlmajk Avatto TRV07 
 * ver. 1.3.4  2023-11-16 kkossev  - (dev. branch) - merged versions 1.3.2 and 1.3.3; 
 * ver. 1.3.5  2023-11-23 vnistor  - (dev. branch) - added childLock status, valve status, battery warning, thermostatMode, setHeatingSetpoint, Valve capability, Preferences: tempCalibration, minTemp, maxTemp to HY367; 
 * ver. 1.3.6  2023-11-24 kkossev  - (dev. branch) - The newly added events are declared as custom attributes;
 * ver. 1.3.7  2023-12-05 kkossev  - (dev. branch) - setting the hysteresis bug fix for AVATTO.
 * ver. 1.3.8  2023-12-08 kkossev  - (dev. branch) - thermostatOperatingState bug fix for BRT-100.
 *
 *                                  TODO: 
 *                                  TODO: parse multiple Tuya DPs in one message;
 *                                  TODO: add option to send digital heatingSetpoint events every hour if no updates are received from the device;
 *                                  TODO: remove homeKitCompatibility option;
 *                                  TODO: HY369 mode processing (dp=4)
 *                                  TODO: tuyaAppVersion in Data section
 *                                  TODO: duplicate check for temperature reports is wrong ! (BEOK sends temp report every 6 seconds ! )
 *                                  TODO: https://community.hubitat.com/t/release-tuya-wall-mount-thermostat-water-electric-floor-heating-zigbee-driver/87050/68?u=kkossev 
 *                                  TODO: add forceOn; 
 *                                  TODO: @user2669  _TZE200_aoclfnxz (MOES) : https://community.hubitat.com/t/release-tuya-wall-mount-thermostat-water-electric-floor-heating-zigbee-driver/87050/60?u=kkossev
 *                                  TODO: @user2669 https://community.hubitat.com/t/release-tuya-wall-mount-thermostat-water-electric-floor-heating-zigbee-driver/87050/65?u=kkossev 
 *          Remarks by amithalp when working on this driver to make it fit the AVATTO2 (manufacturer: _TZE204_lzriup1j)
             tuyaDatapoints: [
                [1, 'system_mode', tuya.valueConverterBasic.lookup({'heat': true, 'off': false})],
                [2, 'current_heating_setpoint', tuya.valueConverter.divideBy10],
                [3, 'local_temperature', tuya.valueConverter.divideBy10],
                [4, 'preset', tuya.valueConverterBasic.lookup({'auto': tuya.enum(1), 'manual': tuya.enum(0), 'temporary_manual': tuya.enum(2)})],
                [9, 'child_lock', tuya.valueConverter.lockUnlock],
                [11, 'faultalarm', tuya.valueConverter.raw],
                [15, 'max_temperature_limit', tuya.valueConverter.divideBy10],
                [19, 'local_temperature_calibration', tuya.valueConverter.localTempCalibration3],
                [101, 'running_state', tuya.valueConverterBasic.lookup({'heat': tuya.enum(1), 'idle': tuya.enum(0)})],
                [102, 'frost_protection', tuya.valueConverter.onOff],
                [103, 'factory_reset', tuya.valueConverter.onOff],
                [104, 'working_day', tuya.valueConverter.workingDay],
                [107, 'deadzone_temperature', tuya.valueConverter.divideBy10],
                [109, null, tuya.valueConverter.ZWT198_schedule],
                [109, 'schedule_weekday', tuya.valueConverter.ZWT198_schedule],
                [109, 'schedule_holiday', tuya.valueConverter.ZWT198_schedule],
                [110, 'backlight_mode', tuya.valueConverter.backlightModeOffLowMediumHigh],
                [111, 'dp111', tuya.valueConverter.onOff],                      // this is for relay inversion from NC (1=normally close) to NO (0=normally open) not listed in Tuya, but device sends datapoint
                // ============== found but not functional datapoints:

                // [16, 'min_temperature_limit', tuya.valueConverter.divideBy10],  // datapoint listed in Tuya, but no communication from device
                // [105, 'dp105', tuya.valueConverter.onOff],                      // not listed in Tuya, but device sends datapoint
                

                // These are the schedule values in bytes, 8 periods in total (4 bytes per period).
                // For each period:
                // 1st byte: hour
                // 2nd byte: minute
                // 3rd, 4th bytes: temperature multiplied by 10
                // On the device last 2 periods are ignored if schedule_mode is 7day. When schedule_mode is disabled,
                // scheduling can't be configured at all on the device.
                // For example, if schedule_mode is weekday/sat+sun and this byte array is received:
                // [6,10,1,144,8,10,0,170,11,40,0,170,12,40,0,170,17,10,0,230,22,10,0,170,8,5,0,200,23,0,0,160]
                // Then the schedule is:
                // Mon-Fri: 6:10 --> 40C, 8:10 --> 17C, 11:40 --> 17C, 12:40 --> 17C, 17:10 --> 23C, 22:10 --> 17C
                // Sat-Sun: 8:05 --> 20C, 23:00 --> 16C
*/

def version() { "1.1.0" }
def timeStamp() {"19/04/2024 18:00"}

import groovy.json.*
import groovy.transform.Field
import hubitat.zigbee.zcl.DataType
import hubitat.device.HubAction
import hubitat.device.Protocol
import java.text.DecimalFormat
import groovy.time.TimeCategory


@Field static final Boolean _DEBUG = false

metadata {
    definition (name: "Tuya Wall Thermostat_AVATTO2", namespace: "kkossev", author: "Krassimir Kossev", importUrl: "https://raw.githubusercontent.com/kkossev/Hubitat-Tuya-Wall-Thermostat/development/Tuya-Wall-Thermostat.groovy", singleThreaded: true ) {
        capability "Actuator"
        capability "Refresh"
        capability "Sensor"
        capability "Temperature Measurement"
        capability "Thermostat"
        capability "ThermostatHeatingSetpoint"
   //     capability "ThermostatCoolingSetpoint"
        capability "ThermostatOperatingState"
        capability "ThermostatSetpoint"
        capability "ThermostatMode"
        capability "Battery"
        capability "HealthCheck"
        
        attribute "childLock", "enum", ["off", "on"]
      //  attribute "windowOpenDetection", "enum", ["off", "on"]
        attribute "brightness", "enum", ['off', 'low', 'medium', 'high']
        attribute "healthStatus", "enum", ["offline", "online", "unknown"]
        attribute "sensorSelection", "enum", sensorOptions.values() as List<String>
        attribute "rtt", "number" 
        attribute "valve", "number" 
     //   attribute "windowOpen", "enum", ["false", "true"]
        attribute "minHeatingSetpoint", "number" 
        attribute "maxHeatingSetpoint", "number" 
        attribute "holidayModeSetpoint", "number" 
        attribute "temperatureOffset", "number"
        attribute "relayState", "enum", ["NO", "NC"]
        
        
        
        if (_DEBUG == true) {
            command "zTest", [
                [name:"dpCommand", type: "STRING", description: "Tuya DP Command", constraints: ["STRING"]],
                [name:"dpValue",   type: "STRING", description: "Tuya DP value", constraints: ["STRING"]],
                [name:"dpType",    type: "ENUM",   constraints: ["DP_TYPE_VALUE", "DP_TYPE_BOOL", "DP_TYPE_ENUM"], description: "DP data type"] 
            ]
            command "test"
        }
        command "initialize", [[name: "Initialize the thermostat after switching drivers.  \n\r   ***** Will load device default values! *****" ]]
        command "childLock",  [[name: "ChildLock", type: "ENUM", constraints: ["off", "on"], description: "Select Child Lock mode"] ]
        //command "windowOpenDetection",  [[name: "windowOpenDetection", type: "ENUM", constraints: ["off", "on"], description: "Select Window Open Detection mode"] ]
        command "setBrightness",  [[name: "setBrightness", type: "ENUM", constraints: ["off", "low", "medium", "high"], description: "Set LCD brightness for BEOK thermostats"] ]
        command "setRelayState",  [[name: "setRelayState", type: "ENUM", constraints: ["NO", "NC"], description: "Set relay to act as NO or NC"] ]
        
        //command "sensorSelection",  [[name: "sensorSelection", type: "ENUM", constraints: ["99":"--- Select ---"] + sensorOptions, description: "Select the temperature sensor"] ]
        
        command "factoryReset", [[name:"factoryReset", type: "STRING", description: "Type 'YES'", constraints: ["STRING"]]]
        command "resetStats", [[name: "Reset Statistics" ]]
        
        
        
         (AVATTO2)
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE204_lzriup1j",  deviceJoinName: "AVATTO2 Wall Thermostat" // Amit 
    }
    preferences {
        if (logEnable == true || logEnable == false) { 
            input (name: "logEnable", type: "bool", title: "<b>Debug logging</b>", description: "<i>Debug information, useful for troubleshooting. Recommended value is <b>false</b></i>", defaultValue: false)
            input (name: "txtEnable", type: "bool", title: "<b>Description text logging</b>", description: "<i>Display measured values in HE log page. Recommended value is <b>true</b></i>", defaultValue: true)
            input (name: "forceManual", type: "bool", title: "<b>Force Manual Mode</b>", description: "<i>If the thermostat changes into schedule mode, then it automatically reverts back to manual mode</i>", defaultValue: false)
            input (name: "resendFailed", type: "bool", title: "<b>Resend failed commands</b>", description: "<i>If the thermostat does not change the Setpoint or Mode as expected, then commands will be resent automatically</i>", defaultValue: false)
            input (name: "minTemp", type: "number", title: "<b>Minimum Temperature</b>", description: "<i>The Minimum temperature setpoint that can be sent to the device</i>", defaultValue: 5, range: "0..60")
            input (name: "maxTemp", type: "number", title: "<b>Maximum Temperature</b>", description: "<i>The Maximum temperature setpoint that can be sent to the device</i>", defaultValue: 35, range: "15..95")
            input (name: "modelGroupPreference", title: "Select a model group. Recommended value is <b>'Auto detect'</b>", /*description: "<i>Thermostat type</i>",*/ type: "enum", options:["Auto detect":"Auto detect", "AVATTO":"AVATTO", "AVATTO2":"AVATTO2", "MOES":"MOES", "BEOK":"BEOK", "BRT-100":"BRT-100", "HY367":"HY367", "HY369":"HY369", "TRV07":"TRV07"], defaultValue: "Auto detect", required: false)        
            input (name: "tempCalibration", type: "decimal", title: "<b>Temperature Calibration</b>", description: "<i>Adjust measured temperature range: -9..9 C</i>", defaultValue: 0.0, range: "-9.0..9.0")
            
            if (getModelGroup() in ['AVATTO2'])  {
                input (name: "programMode", type: "enum", title: "<b>Program Mode</b> (thermostat internal schedule)", description: "<i>Recommended selection is '<b>off</b>'</i>", defaultValue: 0, options: [0:"off", 1:"Mon-Fri", 2:"Mon-Sat", 3: "Mon-Sun"])
            }
           
            input (name: "homeKitCompatibility",  type: "bool", title: "<b>HomeKit Compatibility</b>",  description: "Enable/disable HomeKit Compatibility", defaultValue: false)
            input (name: "PresetMode",  type: "enum", title: "<b>Preset Mode</b>",  description: "Auto or Manual", defaultValue: 0, options: [0:"manual", 1:"auto", 2:"temporary_manual"])
        }
    }
}



@Field static final Map<String, String> Models = [
 //   '
    '_TZE204_lzriup1j'  : 'AVATTO2',      // Tuya AVATTO new Amit
 //   
]


def isAVATTO2()    { return device.getDataValue('manufacturer') in ['_TZE204_lzriup1j'] }

@Field static final Map brightnessOptions = [
    '0' : 'off',
    '1' : 'low',
    '2' : 'medium',
    '3' : 'high'
]


@Field static final Map faultOptions = [
    '0' : 'none',
    '1' : 'e1',
    '2' : 'e2',
    '3' : 'e3'
]

@Field static final Map sensorOptions = [    // BEOK - only in and out; AVATTO + both
    '0' : 'in',
    '1' : 'out',
    '2' : 'both'
]

@Field static final Map programModeOptions = [
    '0' : 'off',
    '1' : 'Mon-Fri',
    '2' : 'Mon-Sat',
    '3' : 'Mon-Sun'
]

@Field static final Integer presenceCountTreshold = 3
@Field static final Integer defaultPollingInterval = 3600
@Field static final Integer MAX_PING_MILISECONDS = 10000     // rtt more than 10 seconds will be ignored
@Field static final Integer COMMAND_TIMEOUT = 10             // timeout time in seconds
@Field static final Integer MaxRetries = 5
@Field static final Integer NOT_SET = -1
                                
private getCLUSTER_TUYA()       { 0xEF00 }
private getSETDATA()            { 0x00 }
private getSETTIME()            { 0x24 }

// Tuya Commands
private getTUYA_REQUEST()       { 0x00 }
private getTUYA_REPORTING()     { 0x01 }
private getTUYA_QUERY()         { 0x02 }
private getTUYA_STATUS_SEARCH() { 0x06 }
private getTUYA_TIME_SYNCHRONISATION() { 0x24 }

// tuya DP type
private getDP_TYPE_RAW()        { "01" }    // [ bytes ]
private getDP_TYPE_BOOL()       { "01" }    // [ 0/1 ]
private getDP_TYPE_VALUE()      { "02" }    // [ 4 byte value ]
private getDP_TYPE_STRING()     { "03" }    // [ N byte string ]
private getDP_TYPE_ENUM()       { "04" }    // [ 0-255 ]
private getDP_TYPE_BITMAP()     { "05" }    // [ 1,2,4 bytes ] as bits


// Parse incoming device messages to generate events
def parse(String description) {
    checkDriverVersion()
    unschedule('deviceCommandTimeout')    
    incRxCtr()
    setHealthStatusOnline()    // was     setPresent()
    if (settings?.logEnable) log.debug "${device.displayName} parse() descMap = ${zigbee.parseDescriptionAsMap(description)}" 
    if (description?.startsWith('catchall:') || description?.startsWith('read attr -')) {
        Map descMap = zigbee.parseDescriptionAsMap(description)
        if (descMap?.clusterInt == zigbee.BASIC_CLUSTER && descMap.attrInt == 0x01) {
            logDebug "Tuya check-in message (attribute ${descMap.attrId} reported: ${descMap.value})"
            def now = new Date().getTime()
            Map lastTxMap = stringToJsonMap( state.lastTx )
            def timeRunning = now.toInteger() - (lastTxMap.pingTime ?: '0').toInteger()
            if (timeRunning < MAX_PING_MILISECONDS) {
                sendRttEvent()
            } 
        }
        else if (descMap?.clusterInt==CLUSTER_TUYA && descMap?.command == "24") {        //getSETTIME
            logDebug "time synchronization request from device, descMap = ${descMap}"
            syncTuyaDateTime()
        } 
        else if (descMap?.clusterInt==CLUSTER_TUYA && descMap?.command == "0B") {    // ZCL Command Default Response
            String clusterCmd = descMap?.data[0]
            def status = descMap?.data[1]            
            if (settings?.logEnable) log.debug "${device.displayName} device has received Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data}"
            setLastRx( NOT_SET, NOT_SET)    // -1
            if (status != "00") {
                if (settings?.logEnable) log.warn "${device.displayName} ATTENTION! manufacturer = ${device.getDataValue("manufacturer")} group = ${getModelGroup()} unsupported Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data} !!!"                
            }
            
        } 
        else if ((descMap?.clusterInt==CLUSTER_TUYA) && (descMap?.command == "01" || descMap?.command == "02")) {
            def transid = zigbee.convertHexToInt(descMap?.data[1])           // "transid" is just a "counter", a response will have the same transid as the command
            def dp = zigbee.convertHexToInt(descMap?.data[2])                // "dp" field describes the action/message of a command frame
            def dp_id = zigbee.convertHexToInt(descMap?.data[3])             // "dp_identifier" is device dependant
            def fncmd = getTuyaAttributeValue(descMap?.data)                 // 
            if (isDuplicated( dp, fncmd )) {
                if (settings?.logEnable) log.debug "(duplicate) transid=${transid} dp_id=${dp_id} <b>dp=${dp}</b> fncmd=${fncmd} command=${descMap?.command} data = ${descMap?.data}" 
                //if ( state.duplicateCounter != null ) state.duplicateCounter = state.duplicateCounter +1
                incDupeCtr()
                return
            }
            else {
                if (settings?.logEnable) log.debug "${device.displayName} dp_id=${dp_id} <b>dp=${dp}</b> fncmdamithalp=${fncmd}"
                setLastRx( dp, fncmd)
            }
            // the switch cases below default to dp_id = "01"
            switch (dp) {
                case 0x01 :  // 'system_mode', tuya.valueConverterBasic.lookup({'heat': true, 'off': false})]
                    switch (getModelGroup()) {
                            case 'AVATTO2' :
                            def switchState = (fncmd == 0) ? "off" : "heat"
                            sendEvent(name: "thermostatMode", value: switchState)
                            if (switchState == "off") {
                                logInfo "switchState reported is: OFF"
                               // sendEvent(name: "thermostatOperatingState", value: "idle")
                            }
                            else {
                                if (settings?.logEnable) {log.info "${device.displayName} switchState reported is: ON and Mode is ${switchState} (dp=${dp}, fncmd=${fncmd})"}
                                //sendEvent(name: "thermostatOperatingState", value: state.lastThermostatOperatingState)
                            }                        
                            //if (switchState == getLastMode())  {
                            //    logDebug "last sent mode ${getLastMode()} is confirmed from the device (dp=${dp}, fncmd=${fncmd})"
                            }
                            //else {
                            //    logWarn "last sent mode ${getLastMode()} DIFFERS from the mode received from the device ${switchState} (dp=${dp}, fncmd=${fncmd})"
                            //}
                            //break
                  
                        //default :
                         //   if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                         //   break
                                       
                    break
                case 0x02 : // 'current_heating_setpoint', tuya.valueConverter.divideBy10]
                    switch (getModelGroup()) {
                      
                        case 'AVATTO2' :
                                          if (settings?.logEnable) log.debug "${device.displayName} -Received message dp=2 and fcmd is ${fncmd} - calling for process TuyaHeatSetpointReport with ${fncmd/10} value </b> "
                                          processTuyaHeatSetpointReport( fncmd/10 ) 
                        
                                    break
                     
                        default :
                            if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                            break
                    }                   
                    break
                case 0x03 :    // 'local_temperature', tuya.valueConverter.divideBy10],
                    logDebug "processing command dp=${dp} fncmd=${fncmd} (lastThermostatMode=${state.lastThermostatMode})" 
                    switch (getModelGroup()) {
                            case 'AVATTO2' :    
                                logDebug "processTuyaTemperatureReport descMap?.size() = ${descMap?.data.size()} dp_id=${dp_id} <b>dp=${dp}</b> :"
                                processTuyaTemperatureReport( fncmd )
                            break
                            default :
                            if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                            break
                    }
                    break
                        case 0x04 :   //  'preset', tuya.valueConverterBasic.lookup({'auto': tuya.enum(1), 'manual': tuya.enum(0), 'temporary_manual': tuya.enum(2)})]
                        switch (getModelGroup()) {
                            case 'AVATTO2' :      
                                def thermostatPresets = ["manual","auto", "temporary_manual"] 
                                def thermostatPreset = thermostatPresets[fncmd]
                                logDebug "${device.displayName} preset mode is <b>${thermostatPreset}</b> (<b>dp=${dp}</b> fncmd=${fncmd})"
                                sendEvent(name: "thermostatPreset", value: thermostatPreset)
                                processPresets( dp, fncmd )
                                break
                            default :
                                if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                                break
                        }
                        break
               
                case 0x09 :     // 'child_lock', tuya.valueConverter.lockUnlock]
                    if (getModelGroup() in ['AVATTO2']) {
                       def childLockState = (fncmd == 0) ? "off" : "on"
                        //logInfo "AVATTO2 Child lock dp=${dp} fncmd=${fncmd}" 
                        logInfo "Child lock reported ${childLockState}"    
                    sendEvent(name: "childLock", value: (fncmd == 0) ? "off" : "on" )
                    }
                    else {
                        if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                    }    
                    break
                case 0x0B :          // [11, 'faultalarm', tuya.valueConverter.raw],  - Not yet implemented
                    break
                case 0x0F :    //  [15, 'max_temperature_limit', tuya.valueConverter.divideBy10]
                               // This parameter is set using menu item 9 on the thermostat menu "set upper themerature limit"  
                   if (getModelGroup() in ['AVATTO2']) {
                         device.updateSetting("maxTemp", [value: fncmd/10 as int , type:"number"]) // This parameter is set using menu item 9 on the thermostat menu "set upper themerature limit"
                         sendEvent(name: "maxHeatingSetpoint", value: fncmd/10)  
                       if (settings?.txtEnable) log.info "${device.displayName} Max Temp Limit is: ${fncmd/10} °C (dp=${dp}, fncmd=${fncmd})"
                            }
                    else {
                        logInfo "unknown dp=${dp} fncmd=${fncmd}"
                    }
                    break
              
                case 0x13 :   //  [19, 'local_temperature_calibration', tuya.valueConverter.localTempCalibration3]
                                // This parameter is set using menu item 1 on the thermostat menu "themerature compensation"
                    if (getModelGroup() in ['AVATTO2']) {
                        processTuyaCalibration( dp, fncmd )
                        if (settings?.txtEnable) log.info "${device.displayName} Calibration Offset is: ${fncmd/10} °C (dp=${dp}, fncmd=${fncmd})"
                    }
                    
                   break
              
                case 0x65 :    // [101, 'running_state', tuya.valueConverterBasic.lookup({'heat': tuya.enum(1), 'idle': tuya.enum(0)})]
                    if (getModelGroup() in ['AVATTO2']) {
                        def switchOperatingState = (fncmd == 1) ? "heating" : ((fncmd == 0) ? "idle" : null)
                        
                        if (settings?.txtEnable) log.info "${device.displayName} Thermostat Operating State is: ${switchOperatingState}"  
                        sendEvent(name: "thermostatOperatingState", value: (fncmd == 0) ? "idle" : "heating" )
                       
                        break    
                      }
                                        
                    
                case 0x66 :     // [102, 'frost_protection', tuya.valueConverter.onOff] -NOT YET IMPLEMENTED
                   
                    break
                
                case 0x67 :    //  [103, 'factory_reset', tuya.valueConverter.onOff] 
                    if (getModelGroup() in ['AVATTO2']) {     // Factory Reset ?
                        def resetRequest = (fncmd == 0) ? "off" : "on"
                        //if (settings?.txtEnable) log.info "${device.displayName} resetRequest is: ${resetRequest}"
                        if (resetRequest == "on") {
                                  if (settings?.txtEnable) log.info "${device.displayName} resetRequest is: ${resetRequest} and Factory Reset was performed"  
                        }
                        else {
                                if (settings?.txtEnable) log.info "${device.displayName} resetRequest is: ${resetRequest} and doing nothing"
                                     }
                       break 
                                                        }
                    else {
                        if (settings?.txtEnable) log.info "${device.displayName} unknown parameter is: ${fncmd} (dp=${dp}, fncmd=${fncmd}, data=${descMap?.data})"
                    }
                    break
                case 0x68 :    //  [104, 'working_day', tuya.valueConverter.workingDay]- NOT YET IMPLEMENTED
                    
                    break
               
                case 0x69 :     // (105) amithalp - not implemented
                    if (getModelGroup() in ['AVATTO2']) {
                        if (settings?.txtEnable) log.info "${device.displayName} AVATTO unknown parameter (105) is: ${fncmd}"                                                      
                    }
                    
                    break
                case 0x6B :     // [107, 'deadzone_temperature', tuya.valueConverter.divideBy10] - NOT YET IMPLEMETED
                    if (getModelGroup() in ['AVATTO2']) {
                        if (settings?.txtEnable) log.info "${device.displayName} AVATTO2 unknown parameter (107) is: ${fncmd}"                                                      
                    }
                   
                    break
               
                case 0x6C :    // (108)    - not implemented                                         
                    if (getModelGroup() in ['AVATTO2']) {  
                        if (settings?.txtEnable) log.info "${device.displayName} AVATTO2 unknown parameter (108) is: ${fncmd}"        
                    }
                
                    break
                
                case 0x6D :    // (109)   - NOT YET IMPLEMENTED                                              
                   if (getModelGroup() in ['AVATTO2']) {  
                        if (settings?.txtEnable) log.info "${device.displayName} AVATTO2 unknown parameter (109) is: ${fncmd}"        
                    }
                
                    break
                
                case 0x6E :       //  [110, 'backlight_mode', tuya.valueConverter.backlightModeOffLowMediumHigh]
                    if (getModelGroup() in ['AVATTO2']) { //set brightness for AVATTO2
                        if (settings?.txtEnable) log.info "${device.displayName} backplane brightness is ${brightnessOptions[fncmd.toString()]} (${fncmd})"
                        device.updateSetting( "brightness",  [value: fncmd.toString(), type:"enum"] )
                        Map lastRxMap = stringToJsonMap( state.lastRx )
                        lastRxMap.setBrightness = brightnessOptions[fncmd.toString()]
                        state.lastRx   = mapToJsonString( lastRxMap)
                        sendEvent(name: "brightness", value: brightnessOptions[fncmd.toString()])
                    }
                  
                    break
                
                 case 0x6F :       //  [111, 'relay mode', 0 is for NO and 1 for NC
                    switch (getModelGroup()) {
                            case 'AVATTO2' :
                            def relayState = (fncmd == 0) ? "NO" : "NC"
                            sendEvent(name: "relayState", value: relayState)
                            if (relayState == "NO") {
                                logInfo "relayState reported is: NO (normally open)"
                                sendEvent(name: "relayState", value: "NO")
                            }
                            else if (relayState == "NC") {
                                logInfo "relayState reported is: NC (normally close)"
                                sendEvent(name: "relayState", value: "NC")
                            }                        
                                   
                    break
                    }
            }
        }
                
               
             //  (dp) switch
        
        else if (descMap?.cluster == "0000") {
            if (settings?.logEnable) log.debug "${device.displayName} basic cluster report  : descMap = ${descMap}"
        } 
        else {
            if (settings?.logEnable) log.warn "not parsed : "+descMap
        }
    } // if catchAll || readAttr
}


def syncTuyaDateTime() {
    // The data format for time synchronization, including standard timestamps and local timestamps. Standard timestamp (4 bytes)    local timestamp (4 bytes) Time synchronization data format: The standard timestamp is the total number of seconds from 00:00:00 on January 01, 1970 GMT to the present.
    // For example, local timestamp = standard timestamp + number of seconds between standard time and local time (including time zone and daylight saving time).                 // Y2K = 946684800 
    def offset = 0
    def offsetHours = 0
    Calendar cal=Calendar.getInstance();    //it return same time as new Date()
    def hour = cal.get(Calendar.HOUR_OF_DAY)
    try {
        offset = location.getTimeZone().getOffset(new Date().getTime()) 
        offsetHours = (offset / 3600000) as int
        logDebug "timezone offset of current location is ${offset} (${offsetHours} hours), current hour is ${hour} h"
    } catch(e) {
        log.error "${device.displayName} cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero"
    }
    //
    def cmds
    cmds = zigbee.command(CLUSTER_TUYA, SETTIME, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8))
    
    logDebug "sending time data : ${cmds}"
    cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
    incTxCtr()
    setLastRx( NOT_SET, NOT_SET)    // -1
}


def processTuyaHeatSetpointReport( fncmd ) 
//this method is called and used to receive the setpoint temperature from the thermostat and update the hubitat device attributes "heatingSetpoint" and "thermostatSetpoint"
{                        
    double setpointValue
    def model = getModelGroup()
    if (getModelGroup() in ['AVATTO2']) {  
            setpointValue = fncmd
    }
    else {
        setpointValue = fncmd 
    }
    setpointValue = setpointValue.round(1)
    if (settings?.txtEnable) log.info "${device.displayName} processTuyaHeatSetpointReport - setpointValue is: ${setpointValue}"+"\u00B0"+"C"
    //if (settings?.txtEnable) log.info "${device.displayName} fncmd Value is: ${fncmd}"
    //if (settings?.txtEnable) log.info "${device.displayName} processTuyaHeatSetpointReport - heatingSetpoint is: ${setpointValue}"+"\u00B0"+"C"
    sendEvent(name: "heatingSetpoint", value: setpointValue, unit: "\u00B0"+"C")
    sendEvent(name: "thermostatSetpoint", value: setpointValue, unit: "\u00B0"+"C")        // Google Home compatibility
    //
    Map lastRxMap = stringToJsonMap( state.lastRx )
    lastRxMap.setPoint = setpointValue
    state.lastRx   = mapToJsonString( lastRxMap)      // state.lastRx
}                        

def processTuyaTemperatureReport( fncmd ) 
//this method is called and used to receive the currentTemperature from the thermostat and update the hubitat device attribute "temperature" 
{
    double currentTemperatureValue
    def model = getModelGroup()
    switch (model) {
        case 'AVATTO2' :
            currentTemperatureValue = fncmd / 10.0 
            break
        default :
            currentTemperatureValue = fncmd
            break
    }    
    if (currentTemperatureValue > 50 || currentTemperatureValue < 1) {
        log.warn "${device.displayName} invalid temperature : ${currentTemperatureValue}"
        // auto correct patch!
        currentTemperatureValue = currentTemperatureValue / 10.0
        log.warn "auto correct patch for temperature!"
    }
    if (settings?.txtEnable) log.info "${device.displayName} temperature is: ${currentTemperatureValue}"+"\u00B0"+"C"
    sendEvent(name: "temperature", value: currentTemperatureValue, unit: "\u00B0"+"C")
}

def processTuyaCalibration( dp, fncmd )
{
    def temp = fncmd/10 
    double doubleCalib = temp
    if (getModelGroup() in ['AVATTO2'] && dp == 19) { // 0x13
        device.updateSetting("tempCalibration", [value: temp , type:"decimal"])
        sendEvent(name: "temperatureOffset", value: temp, unit: "\u00B0"+"C")
        logDebug "calibration is: ${temp}"
    }
    
    else {
        if (settings?.logEnable) log.warn "${device.displayName} UNSUPPORTED temperature calibration for modelGroup=${getModelGroup()} : ${temp} (dp=${dp}, fncmd=${fncmd}) "
    }

    if (settings?.txtEnable) log.info "${device.displayName} temperature calibration (correction) is: ${doubleCalib} °C (dp=${dp}, fncmd=${fncmd}) "
}

def processPresets( dp, data ) {
    logDebug "processPresets fp-${dp} data=${data}"
    // 0x0401 # Mode (Received value 0:Manual / 1:Holiday / 2:Temporary Manual Mode / 3:Prog)
    // KK TODO - check why the difference for values 0 and 3 ?
    /*
    0x0401 :
    0 : Manual Mode
    1 : Holiday Mode
    2 : Temporary Manual Mode (will return to Schedule mode at the next schedule time)
    3 : Schedule Programming Mode


    TRV sends those values when changing modes:
    1 for Manual
    0 for Schedule
    2 for Temporary manual (in Schedule)
    3 for Away

    Schedule -> [0] for attribute 0x0401
    Manual -> [1] for attribute 0x0401
    Temp Manual -> [2] for attribute 0x0401
    Holiday -> [3] for attribute 0x0401

    */
    
    def mode
    def preset
    
    if (data == 0) { //namual
        mode = "heat"
        preset = "manual"
        }
    else if (data == 1) { //auto
        mode = "auto"
        preset = "auto"
    }
    else if (data == 2) { //temporary_manual
        mode = "heat"
        preset = "manual"
    }
    //temporary_manual
    //else if (data == 3) { //holiday
    //    mode = "off"    // BRT-100 'holiday' preset is matched to 'off' mode!
    //    preset = "holiday"
  //  }
    else {
        if (settings?.logEnable) log.warn "${device.displayName} processPresets unknown: ${data}"
        return;
    }
    /*if (state.lastThermostatMode == "emergency heat") {
        runIn(2, sendTuyaBoostModeOff)    // also turn boost off!
    }*/

    sendEvent(name: "thermostatMode", value: mode)    // mode was confirmed from the Preset info data...
    state.lastThermostatMode = mode
    
    // TODO - change tehrmostatPreset depending on preset ?
    if (settings?.txtEnable) log.info "${device.displayName} Presets: mode = ${mode} preset = ${preset}"
}

def processTuyaModes3( dp, data ) {
    // dp = 0x0402 : // preset for moes or mode
    // dp = 0x0403 : // preset for moes    
    if (getModelGroup() in ['BRT-100', 'HY367', 'HY369']) {    // BRT-100 ?    KK: TODO!
        def mode
        if (data == 0) { mode = "auto" } //schedule
        else if (data == 1) { mode = "heat" } //manual
        else if (data == 2) { mode = "off" } //away
        else {
            if (settings?.logEnable) log.warn "${device.displayName} processTuyaModes3: unknown mode: ${data}"
            return
        }
        if (settings?.txtEnable) log.info "${device.displayName} mode is: ${mode}"
        // TODO - - change thremostatMode depending on mode ?
    }
    else {    // NOT TESTED !!
        def preset
        if (dp == 0x02) { // 0x0402
            preset = "auto" 
        }
        else if (dp == 0x03) { // 0x0403
            preset = "program"
        }
        else {
            if (settings?.logEnable) log.warn "${device.displayName} processTuyaMode3: unknown preset: dp=${dp} data=${data}"
            return
        }
        if (settings?.txtEnable) log.info "${device.displayName} preset is: ${preset}"
        // TODO - - change preset ?
    }
}

/*def processTuyaBoostModeReport( fncmd )
{
    def boostMode = fncmd == 0 ? "off" : "on"                // 0:"off" : 1:"boost in progress"
    if (settings?.txtEnable) log.info "${device.displayName} Boost mode is: $boostMode (0x${fncmd})"
    if (boostMode == "on") {
        sendEvent(name: "thermostatMode", value: "emergency heat")
        state.lastThermostatMode = "emergency heat"
        sendThermostatOperatingStateEvent("heating")
    }
    else {
        if (device.currentState('thermostatMode').value == "emergency heat") {
            // restore the lastThermostatMode
            if (settings?.txtEnable) log.info "${device.displayName} restoring the lastThermostatMode: ${state.lastThermostatMode}"
            setThermostatMode(state.lastThermostatMode)
        }
        else {
            if (settings?.logEnable) log.debug "boost is already off - last thermostatMode was ${device.currentState('thermostatMode').value}"
        }
    }
}
*/

private int getTuyaAttributeValue(ArrayList _data) {
    int retValue = 0
    
    if (_data.size() >= 6) {
        int dataLength = _data[5] as Integer
        int power = 1;
        for (i in dataLength..1) {
            retValue = retValue + power * zigbee.convertHexToInt(_data[i+5])
            power = power * 256
        }
    }
    return retValue
}

def sendThermostatOperatingStateEvent( st ) {
    sendEvent(name: "thermostatOperatingState", value: st)
    state.lastThermostatOperatingState = st
}

def guessThermostatOperatingState() {
    try {
        double dTemp = Double.parseDouble(device.currentState('temperature').value)
        double dSet  = Double.parseDouble(device.currentState('heatingSetpoint').value)
 
        if (dTemp >= dSet) {
            if (settings?.txtEnable) log.debug "guessing operating state is IDLE"
            return "idle"
        }
        else {
            if (settings?.txtEnable) log.debug "guessing operating state is HEAT"
            return "heat"
        }
    }
    catch (NumberFormatException e) {
        return "unknown"
    }
}

/*def sendTuyaBoostModeOff() {
    ArrayList<String> cmds = []
    if (settings?.txtEnable) log.info "${device.displayName} turning Boost mode off"
    sendThermostatOperatingStateEvent( guessThermostatOperatingState() )
    //sendEvent(name: "thermostatOperatingState", value: guessThermostatOperatingState())
    cmds = sendTuyaCommand("04", DP_TYPE_BOOL, "00")
    sendZigbeeCommands( cmds )    
}
*/
// called from setThermostatMode( mode ) only
// TODO - refactor (switch by model) !
def sendTuyaThermostatMode( mode ) {
    ArrayList<String> cmds = []
    def dp = ""
    def fn = ""   
    def model = getModelGroup()
    switch (mode) {
        case "off" :    // 
            if (model in ['AVATTO2']) {
                dp = "01"
                fn = "00"
            }
            else {    // all other models
                dp = "01"                            
                fn = "00"    // changed 10/23/2022 defauilt to DP1 FN=0 
            }
            break
        case "heat" :    // manual mode
            if (model in ['AVATTO2']) {    
                if (device.currentState('thermostatMode').value == "off") {
                    cmds += switchThermostatOn()
                }
                dp = "01"    // was "01" 
                fn = "01"    // was "01" 
            }
            else {    // all other models    // not tested!
                dp = "02"                            
                fn = "00"    // changed 10/23/2022 defauilt to DP2 FN=0 
            }
            break
        // amithalp - not implemented all the below modes

        case "auto" :    // scheduled mode
            logDebug "sending AUTO mode!"
            if (model in ['AVATTO', 'MOES', 'BEOK']) {    // TODO - does not switch off manual mode ?
                if (device.currentState('thermostatMode').value == "off") {
                    cmds += switchThermostatOn()
                }
                dp = "02"
                fn = "01"
            }
            else if (model in ['BRT-100']) {
                dp = "01"                       
                fn = "00"  
                return sendTuyaCommand(dp, DP_TYPE_ENUM, fn)    // BRT-100 DP=1 needs DP_TYPE_ENUM!
            }
            else if (model in ["TRV07"]) {
                dp = "01"
                fn = "00"
            }
            else if (model in ["HY367"]) {
                dp = "04"
                fn = "01"
            }
            else {    // all other models    // not tested!
                dp = "02"                            
                fn = "01"    // changed 10/23/2022 defauilt to DP2 FN=1 
            }
            break
        
        case "on" :
            if (model in ["TRV07"]) {
                dp = "01"
                fn = "03"
            }
            else {    // all other models do not support "on" ! Is this actually true???
                if (settings?.txtEnable) log.warn "${device.displayName} 'on' mode is not supported by this device"
                return null
            }
            break
        case "holiday":
            if (model in ["HY367"]) {
                dp = "04"
                fn = "00"
            }
            else {    // all other models do not support "on" ! Is this actually true???
                if (settings?.txtEnable) log.warn "${device.displayName} 'holiday' mode is not supported by this device"
                return null
            }
            break
        
        
            log.warn "Unsupported mode ${mode}"
            return null
    }
    //wakeUpTuya()
    cmds += sendTuyaCommand(dp, mode == "off" ? DP_TYPE_BOOL : DP_TYPE_ENUM, fn)
    sendZigbeeCommands( cmds )
}

// called from heat() off() auto() ...
// sends TuyaCommand and checks after 4 seconds
def setThermostatMode( mode ) {
    if (settings?.logEnable) log.debug "${device.displayName} sending setThermostatMode(${mode})"
    setLastTx( mode=mode, isModeSetReq=true)
    //state.mode = mode
    runIn(4, modeReceiveCheck)
    sendTuyaThermostatMode( mode )
}



def sendTuyaHeatingSetpoint( temperature ) {
    if (settings?.logEnable) log.debug "${device.displayName} sendTuyaHeatingSetpoint(${temperature})"
    def settemp = temperature as int
    def dp = "10"
    def model = getModelGroup()
    switch (model) {
        case 'AVATTO2' :                          // AVATTO2 - only integer setPoints!
            dp = "02"
            settemp = temperature * 10
            break
        default :
            settemp = temperature
            break
    }    
    if (settings?.logEnable) log.debug "${device.displayName} changing setpoint to ${settemp}"
    //
    Map lastTxMap = stringToJsonMap( state.lastTx )
    lastTxMap.isSetPointReq = true
    lastTxMap.setPoint = temperature    // BEOK - float value!
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    //
    runIn(3, setpointReceiveCheck)
    sendZigbeeCommands( sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(settemp as int, 8)) )
}

def setThermostatSetpoint( temperature ) {
    setHeatingSetpoint( temperature )
}

//  ThermostatHeatingSetpoint command
//  sends TuyaCommand and checks after 4 seconds
//  1°C steps. (0.5°C setting on the TRV itself, rounded for zigbee interface)
def setHeatingSetpoint( temperature ) {
    def previousSetpoint = device.currentState('heatingSetpoint', true).value /*as int*/
    double tempDouble
    logDebug "setHeatingSetpoint temperature = ${temperature}  as int = ${temperature as int} (previousSetpointt = ${previousSetpoint})"
    if (settings?.maxTemp == null || settings?.minTemp == null ) { device.updateSetting("minTemp", [value: 5 , type:"number"]);  device.updateSetting("maxTemp", [value: 35 , type:"number"])   } // default is 10, so we should set 10 for consistency

   /* if (isBEOK() || isTRV07() || isHY367()) {
        if (settings?.logEnable) log.debug "0.5 C correction of the heating setpoint${temperature} for BEOK"
        tempDouble = safeToDouble(temperature)
        tempDouble = Math.round(tempDouble * 2) / 2.0
    }*/
     
       //the lines below are ignored to allow for 0.5 changes    
       /* if (temperature != (temperature as int)) {
            if ((temperature as double) > (previousSetpoint as double)) {
                temperature = (temperature + 0.5 ) as int
            }
            else {
                temperature = temperature as int
            }
        logDebug "corrected heating setpoint${temperature}"
        }*/
        tempDouble = temperature
    
    if (tempDouble > settings?.maxTemp.value ) tempDouble = settings?.maxTemp.value
    if (tempDouble < settings?.minTemp.value ) tempDouble = settings?.minTemp.value
    tempDouble = tempDouble.round(1)
    sendEvent(name: "heatingSetpoint", value: tempDouble, unit: "\u00B0"+"C")
    sendEvent(name: "thermostatSetpoint", value: tempDouble, unit: "\u00B0"+"C")
    updateDataValue("lastRunningMode", "heat")
    
    state.heatingSetPointRetry = 0
    sendTuyaHeatingSetpoint( tempDouble )
}


/* def setCoolingSetpoint(temperature){
    if (settings?.logEnable) log.debug "${device.displayName} setCoolingSetpoint(${temperature}) called!"
    if (temperature != (temperature as int)) {
        temperature = (temperature + 0.5 ) as int
        logDebug "corrected temperature: ${temperature}"
    }
    sendEvent(name: "coolingSetpoint", value: temperature, unit: "\u00B0"+"C")
} */

def heat(){
    setThermostatMode("heat")
}

def off(){
    setThermostatMode("off")
}

def on() {
    heat()
}

//def setThermostatFanMode(fanMode) { sendEvent(name: "thermostatFanMode", value: "${fanMode}", descriptionText: getDescriptionText("thermostatFanMode is ${fanMode}")) }

//def auto() { setThermostatMode("auto") }
//def emergencyHeat() { setThermostatMode("emergency heat") }
//def cool() { setThermostatMode("cool") }
//def fanAuto() { setThermostatFanMode("auto") }
//def fanCirculate() { setThermostatFanMode("circulate") }
//def fanOn() { setThermostatFanMode("on") }
def setSchedule(schedule) { if (settings?.logEnable) log.debug "${device.displayName} setSchedule (${schedule}) called!"} 

def setManualMode() {
    if (settings?.logEnable) log.debug "${device.displayName} setManualMode()"
    ArrayList<String> cmds = []
    cmds = sendTuyaCommand("02", DP_TYPE_ENUM, "00") + sendTuyaCommand("03", DP_TYPE_ENUM, "01")    // iquix code  // TODO: check!
    sendZigbeeCommands( cmds )
}

def switchThermostatOn() {
    if (settings?.logEnable) log.info "${device.displayName} switching On!"
    ArrayList<String> cmds = []
    cmds = sendTuyaCommand("01", DP_TYPE_BOOL, "01", delay=2750)    // increased delay to 2750 on 1/27/2022
    return cmds
}


/**
 * Returns the model group of the device based on its manufacturer.
 * If modelGroupPreference is set to "Auto detect", it will try to match the manufacturer with a known model group.
 * If no match is found, it will return "UNKNOWN".
 * If modelGroupPreference is set to a specific model group, it will return that model group.
 * @return The model group of the device.
 */
def getModelGroup() {
    def manufacturer = device.getDataValue("manufacturer")
    def modelGroup = 'UNKNOWN'
    if (modelGroupPreference == null) {
        device.updateSetting("modelGroupPreference", "Auto detect")
    }
    if (modelGroupPreference == "Auto detect") {
        if (manufacturer in Models) {
            modelGroup = Models[manufacturer]
        }
        else {
             modelGroup = 'UNKNOWN'
        }
    }
    else {
         modelGroup = modelGroupPreference 
    }
    //logDebug "${device.displayName} manufacturer ${manufacturer} group is ${modelGroup}"
    return modelGroup
}



def sendSupportedThermostatModes() {
    def supportedThermostatModes = []
    switch (getModelGroup()) {
        //case 'AVATTO' :
        case 'AVATTO2' :
            supportedThermostatModes = ["off", "heat"]
            break
        //case 'MOES' :
        //case 'BEOK' :
        //    supportedThermostatModes = ["off", "heat", "auto"]
        //    break
        //case 'BRT-100' :  // BRT-100
        //    supportedThermostatModes = ["off", "heat", "auto", "emergency heat"]
        //    break
        //case 'HY367' :  // HY367
        //    supportedThermostatModes = ["holiday", "auto", "heat", "comfort", "eco", "emergency heat", "temp_auto", "valve"]
        //    break
        //default :
        //    supportedThermostatModes = ["off", "heat", "auto"]
        //    break
    }    
    sendEvent(name: "supportedThermostatModes", value:  JsonOutput.toJson(supportedThermostatModes), isStateChange: true)
}

def sendSupportedThermostatOperatingModes() {
    def supportedThermostatOperatingModes = []
    switch (getModelGroup()) {
        case 'AVATTO2' :
            supportedThermostatOperatingModes = ["idle", "heat"]
            break
       }    
    sendEvent(name: "supportedThermostatOperatingModes", value:  JsonOutput.toJson(supportedThermostatOperatingModes), isStateChange: true)
}


def installed() {
//  called from initialize()
    if (settings?.txtEnable) log.info "installed()"
    
    //sendEvent(name: "supportedThermostatFanModes", value: JsonOutput.toJson(["auto", "circulate", "on"]), isStateChange: true)    
    sendSupportedThermostatModes()
    sendEvent(name: "thermostatMode", value: "heat", isStateChange: true)
    //sendEvent(name: "thermostatFanMode", value: "auto", isStateChange: true)
    state.lastThermostatMode = "heat"
    sendThermostatOperatingStateEvent( "idle" )
    sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true)
    //sendEvent(name: "thermostatSetpoint", value:  20.0, unit: "\u00B0"+"C", isStateChange: true)        // Google Home compatibility
    sendEvent(name: "heatingSetpoint", value: 24.0, unit: "\u00B0"+"C", isStateChange: true)
    //sendEvent(name: "coolingSetpoint", value: 30.0, unit: "\u00B0"+"C", isStateChange: true)
    sendEvent(name: "temperature", value: 22.0, unit: "\u00B0"+"C", isStateChange: true)    
    updateDataValue("lastRunningMode", "heat")    

    //state.setpoint = 0
    unschedule()
    runEvery1Minute(receiveCheck)    // KK: check
}

def updated() {
//  called from initialize()
    ArrayList<String> cmds = []
    if (settings?.modelGroupPreference == null) {
        device.updateSetting("modelGroupPreference", [value:"Auto detect", type:"enum"])
        state.deviceProfile = "AUTO_DETECT"
    }

    // log.warn "settings?.modelGroupPreference = ${settings?.modelGroupPreference}"
    if (settings?.modelGroupPreference != null) {
        logDebug "current state.deviceProfile=${state.deviceProfile}, settings.modelGroupPreference=${settings?.modelGroupPreference}, getModelGroup()=${getModelGroup()}"
        if (settings?.modelGroupPreference != state.deviceProfile) {
            logWarn "changing the device profile from ${state.deviceProfile} to ${settings?.modelGroupPreference}"
            state.deviceProfile = settings?.modelGroupPreference
            initializeVars(fullInit = false) 
            //resetPreferencesToDefaults(debug=true)
            logInfo "press F5 to refresh the page"
        }
    }
    else {
        logDebug "modelGroupPreference is not set"
    }

    /* unconditional */log.info "Updating ${device.getLabel()} (${device.getName()}) model ${device.getDataValue('model')} manufacturer <b>${device.getDataValue('manufacturer')}</b> modelGroupPreference = <b>${modelGroupPreference}</b> (${getModelGroup()})"
    if (settings?.txtEnable) log.info "Force manual is <b>${forceManual}</b>; Resend failed is <b>${resendFailed}</b>"
    if (settings?.txtEnable) log.info "Debug logging is <b>${logEnable}</b>; Description text logging is <b>${txtEnable}</b>"
    /*if (!(getModelGroup() in ['BRT-100'])) {
        if (settings?.homeKitCompatibility?.value  == true && device.currentValue("battery", true) == null) {
            sendEvent(name: 'battery', value: 100, unit: "%", type: "digital", descriptionText: "homeKitCompatibility on", isStateChange: true )    
        }
        else if (settings?.homeKitCompatibility?.value  == false && device.currentValue("battery", true) != null) {
            sendEvent(name: 'homeKitCompatibility', value: "off", unit: "%", type: "digital", descriptionText: "homeKitCompatibility off", isStateChange: true )    // for the record
            device.deleteCurrentState("battery")
        }
    }*/
    if (logEnable==true) {
        runIn(86400, logsOff, [overwrite: true, misfire: "ignore"])    // turn off debug logging after 24 hours
    }
    else {
        unschedule(logsOff)
    }
    runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
    def fncmd
    def dp
    // tempCalibration
    dp = getModelGroup() in ['AVATTO2'] ? "13" : null
    if (getModelGroup() in ['AVATTO2'] && dp != null) {
        logDebug "tempCalibration = ${tempCalibration}"
        fncmd = getModelGroup() in ['AVATTO2'] ? (safeToDouble( tempCalibration )*10) as int : safeToDouble( tempCalibration ) as int
        logDebug "tempCalibration fncmd = ${fncmd}"
        logDebug "setting tempCalibration to ${tempCalibration} (${fncmd})"
        cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(fncmd as int, 8))  
    } 
    // hysteresis
        //not supported by AVATTO2
    
    // minTemp
    //not supported by AVATTO2
   
    // maxTemp
    dp =  getModelGroup() in ['AVATTO2'] ? "0F" : null
    if (dp != null && getModelGroup() in ['AVATTO2']) {
        fncmd = safeToInt( maxTemp )
        //if (settings?.logEnable) 
        logDebug "${device.displayName} setting maxTemp to= ${fncmd*10}"
        cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(fncmd*10 as int, 8))
    }
  
    // tempCeiling - amithalp NOT YET FIXED
    dp = getModelGroup() in ['BEOK'] ? "66" : null
    if (getModelGroup() in ['BEOK'] && dp != null) {    // TODO: tempCeiling for AVATTO and MOES !
        fncmd = safeToInt( tempCeiling ) // whole number!
        if (settings?.logEnable) log.trace "${device.displayName} setting tempCeiling to ${tempCeiling} (${fncmd})"
        cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(fncmd as int, 8))
    }
    // programMode - amithalp NOT YET FIXED
    if (getModelGroup() in ['AVATTO2']) {
        if (settings?.programMode != null) {
            def value = safeToInt( programMode )
            if (settings?.logEnable) log.debug "${device.displayName} setting Program Mode to ${programModeOptions[value.toString()]} (${programMode})"
            cmds += sendTuyaCommand("68", DP_TYPE_ENUM, zigbee.convertToHexString(value as int, 2))
        }
    }
    // sound - amithalp NOT YET FIXED
   /* if (isBEOK()) {
        fncmd = settings?.sound == false ? 0 : 1
        if (settings?.logEnable) log.trace "${device.displayName} setting sound to ${fncmd} (${fncmd==0?'off':'on'})"
        cmds += sendTuyaCommand("07", DP_TYPE_BOOL, zigbee.convertToHexString(fncmd as int, 2))
    }*/
    // frostProtection - amithalp NOT YET FIXED
    if (isAVATTO2()) {
        fncmd = settings?.frostProtection == false ? 0 : 1
        if (settings?.logEnable) log.trace "${device.displayName} setting frost protection to ${fncmd} (${fncmd==0?'off':'on'})"
        cmds += sendTuyaCommand("66", DP_TYPE_BOOL, zigbee.convertToHexString(fncmd as int, 2))
    }
    
    // brightness
    if (isAVATTO2())  {
        if (settings?.logEnable) log.trace "settings?.brightness = ${settings?.brightness}"
        if (settings?.brightness != null) {
            def key = safeToInt(settings?.brightness)
            def value = brightnessOptions[key.toString()]
            //log.trace "key=${key} value=${value}"
            if (value != null) {
                def dpValHex = zigbee.convertToHexString(key as int, 2)
                cmds += sendTuyaCommand("6E", DP_TYPE_ENUM, dpValHex)            
                if (settings?.logEnable) log.debug "${device.displayName} setting brightness to ${value} ($key)"
            }
        }
    }

    if (cmds.size() > 3) {
        logInfo "Update finished"
        logDebug "cmds = ${cmds}"
        sendZigbeeCommands( cmds )
    }
    else {
        if (settings?.logEnable) log.debug "${device.displayName} nothing to update"
    }
    //
   /* if (isBEOK()) {
        syncTuyaDateTime()
    }*/
}

def refresh() {
//called from refresh at the device page
    ArrayList<String> cmds = []
    def model = getModelGroup()
    def fncmd
    if (settings?.txtEnable)  {log.info "${device.displayName} refresh() ${model}..."}
    switch (model) {
       case 'AVATTO2' :  // wakes up AVATTO - LCD display goes to normal brightness
            fncmd = 0
            cmds += sendTuyaCommand("27", DP_TYPE_ENUM, zigbee.convertToHexString(fncmd as int, 8))
            break
        default :
            cmds += zigbee.readAttribute(0 , 0 )
            break
    }
    sendZigbeeCommands( cmds ) 
}

def factoryReset( yes ) {
    ArrayList<String> cmds = []
    def model = getModelGroup()    
    if (yes != "YES") {
        log.warn "${device.displayName} type '<b>YES</b>' to confirm ${model} factory resetting!"
        return
    }

    def fncmd
    log.warn "${device.displayName} FACTORY RESET ${model}..."
    switch (model) {
        case 'AVATTO2' :
            fncmd = 1    // reset!
            cmds += sendTuyaCommand("67", DP_TYPE_BOOL, zigbee.convertToHexString(fncmd as int, 2))
            log.info "${device.displayName} FACTORY RESETING ${model}..."
            break
        default :
            cmds += zigbee.readAttribute(0 , 0 )
            break
    }
    sendZigbeeCommands( cmds )     
}


def driverVersionAndTimeStamp() {version()+' '+timeStamp()}

/**
 * Checks if the driver version has changed and updates the settings if necessary.
 * If the driver version has changed, the method initializes the variables, removes deprecated state variables,
 * and resets the statistics. Finally, it updates the driver version in the state.
 */
def checkDriverVersion() {
    if (state.driverVersion == null || driverVersionAndTimeStamp() != state.driverVersion) {
        if (txtEnable==true) log.debug "${device.displayName} updating the settings from the current driver version ${state.driverVersion} to the new version ${driverVersionAndTimeStamp()}"
        initializeVars( fullInit = false ) 
        if (device.currentValue("presence", true) != null) {
            device.deleteCurrentState("presence")                // removed from version 1.3.0
        }
        if (state.rxCounter != null) state.remove("rxCounter")
        if (state.txCounter != null) state.remove("txCounter")
        if (state.old_dp != null)    state.remove("old_dp")
        if (state.old_fncmd != null) state.remove("old_fncmd")
        if (state.setpoint != null)  state.remove("setpoint")
        if (state.modeSetRetry != null)  state.remove("modeSetRetry")
        if (state.heatingSetPointRetry != null)  state.remove("heatingSetPointRetry")
        //
        if (state.lastRx == null || state.stats == null || state.lastTx == null) {
            resetStats()
        }
        state.driverVersion = driverVersionAndTimeStamp()
    }
}

def setPresent() { setHealthStatusOnline() }    // trap for backward compatibility versions prior 1.3.0
def pollPresence() { deviceHealthCheck() }      // trap for backward compatibility versions prior 1.3.0

// 
/**
 * Called when any event was received from the Zigbee device in parse() method..
 * Sets the health status of the device to "online" if it is not already set to "online".
 * Sends a health status event and logs that the device is now online.
 * Schedules a device health check to run after the default polling interval.
 */
def setHealthStatusOnline() {
    if (!((device.currentValue('healthStatus') ?: 'unknown') in ['online']))  {
        sendHealthStatusEvent('online')
        logInfo "is now online!"
        runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
    }
    state.notPresentCounter = 0
}


/**
 * called every 60 minutes
 * Checks the health status of the device and sends an event if it is offline.
 * Also synchronizes the date and time if the device is a BEOK thermostat.
 *
 * @return none
 */
def deviceHealthCheck() {
    if (state.notPresentCounter != null) {
        state.notPresentCounter = state.notPresentCounter + 1
        if (state.notPresentCounter >= presenceCountTreshold) {
            if ((device.currentValue("healthStatus") ?: 'unknown') != 'offline' ) {
                logWarn "not present!"
                sendHealthStatusEvent('offline')
            }
        }
    }
    else {
        state.notPresentCounter = 0  
    }
    //if (isBEOK())  {
    //    syncTuyaDateTime()
    //}
    runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
}

void sendHealthStatusEvent(value) {
    def descriptionText = "healthStatus changed to ${value}"
    sendEvent(name: "healthStatus", value: value, descriptionText: descriptionText, isStateChange: true, isDigital: true)
    if (value == 'online') {
        logInfo "${descriptionText}"
    }
    else {
        if (settings?.txtEnable) { log.warn "${device.displayName}} <b>${descriptionText}</b>" }
    }
}


def ping() {
    logInfo 'ping...'
    scheduleCommandTimeoutCheck()
    Map lastTxMap = stringToJsonMap(state.lastTx)
    lastTxMap.pingTime = new Date().getTime()
    sendZigbeeCommands( zigbee.readAttribute(zigbee.BASIC_CLUSTER, 0x01, [:], 0) )
    state.lastTx = mapToJsonString( lastTxMap )
}

private void scheduleCommandTimeoutCheck(int delay = COMMAND_TIMEOUT) {
    runIn(delay, 'deviceCommandTimeout')
}

void deviceCommandTimeout() {
    logWarn 'no response received (sleepy device or offline?)'
    sendRttEvent("timeout")
}

void sendRttEvent( String value=null) {
    def now = new Date().getTime()
    Map lastTxMap = stringToJsonMap( state.lastTx )
    def timeRunning = now.toInteger() - (lastTxMap.pingTime ?: now).toInteger()
    def descriptionText = "Round-trip time is ${timeRunning} (ms)"
    if (value == null) {
        logInfo "${descriptionText}"
        sendEvent(name: "rtt", value: timeRunning, descriptionText: descriptionText, unit: "ms", isDigital: true)    
    }
    else {
        descriptionText = "Round-trip time is ${value}"
        logInfo "${descriptionText}"
        sendEvent(name: "rtt", value: value, descriptionText: descriptionText, isDigital: true)    
    }
}


def logInitializeRezults() {
    log.info "${device.displayName} manufacturer  = ${device.getDataValue("manufacturer")} ModelGroup = ${getModelGroup()}"
    log.info "${device.displayName} Initialization finished\r                          version=${version()} (Timestamp: ${timeStamp()})"
}

// called by initialize() button
void initializeVars( boolean fullInit = true ) {
    if (settings?.txtEnable) log.info "${device.displayName} InitializeVars()... fullInit = ${fullInit}"
    if (fullInit == true ) {
        state.clear()
        resetStats()
        state.driverVersion = driverVersionAndTimeStamp()
    }
    if (device.currentValue('healthStatus') == null) sendHealthStatusEvent('unknown')    
    //
    setLastRx( NOT_SET, NOT_SET)    // -1
    state.packetID = 0
    //
    if (fullInit == true || state.lastThermostatMode == null) state.lastThermostatMode = "unknown"
    if (fullInit == true || state.lastThermostatOperatingState == null) state.lastThermostatOperatingState = "unknown"
    if (fullInit == true || state.notPresentCounter == null) state.notPresentCounter = 0
    //
    if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", true)
    if (fullInit == true || settings?.txtEnable == null) device.updateSetting("txtEnable", true)
    if (fullInit == true || settings?.forceManual == null) device.updateSetting("forceManual", false)    
    if (fullInit == true || settings?.resendFailed == null) device.updateSetting("resendFailed", false)    
   // if (fullInit == true || settings?.minTemp == null) device.updateSetting("minTemp", [value: 5 , type:"number"])    
    if (fullInit == true || settings?.maxTemp == null) device.updateSetting("maxTemp", [value: 35 , type:"number"])
    if (fullInit == true || settings?.tempCeiling == null) device.updateSetting("tempCeiling", [value: 35 , type:"number"])
    if (fullInit == true || settings?.tempCalibration == null) device.updateSetting("tempCalibration", [value:0.0, type:"decimal"])
   // if (fullInit == true || settings?.hysteresis == null) device.updateSetting("hysteresis", [value:1.0, type:"decimal"])
    //if (fullInit == true || settings?.sound == null) device.updateSetting("sound", true)    
    if (fullInit == true || settings?.frostProtection == null) device.updateSetting("frostProtection", true)    
    if (fullInit == true || settings?.brightness == null) device.updateSetting("brightness", [value:"3", type:"enum"])
    if (fullInit == true || settings?.homeKitCompatibility == null) device.updateSetting("homeKitCompatibility", true)    
    
    //
}

def configure() {
    initialize()
}

def initialize() {
    if (true) "${device.displayName} Initialize()..."
    unschedule()
    initializeVars()
    runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
    setDeviceLimits()
    installed()
    updated()
    runIn( 3, logInitializeRezults)
}

def setDeviceLimits() { // for google and amazon compatability
    sendEvent(name:"minHeatingSetpoint", value: settings.minTemp ?: 5, unit: "°C", isStateChange: true)
    sendEvent(name:"maxHeatingSetpoint", value: settings.maxTemp ?: 35, unit: "°C", isStateChange: true)
    updateDataValue("lastRunningMode", "heat")
    if (settings?.logEnable) log.trace "setDeviceLimits - device max/min set"
}    

// scheduled for call from setThermostatMode() 4 seconds after the mode was potentiually changed.
// also, called every 1 minute from receiveCheck()
def modeReceiveCheck() {
    if (settings?.resendFailed == false )
        return
    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isModeSetReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    
    if (lastTxMap.mode != device.currentState('thermostatMode', true).value) {
        lastTxMap['setModeRetries'] = lastTxMap['setModeRetries'] + 1
        logWarn "modeReceiveCheck() <b>failed</b> (expected ${lastTxMap['mode']}, current ${device.currentState('thermostatMode', true).value}), retry#${lastTxMap['setModeRetries']}"
        if (lastTxMap['setModeRetries'] < MaxRetries) {
            logDebug "resending mode command : ${lastTxMap['mode']}"
            statsMap['txFailCtr'] = statsMap['txFailCtr'] + 1
            setThermostatMode( lastTxMap['mode'] )
        }
        else {
            logWarn "modeReceiveCheck(${lastTxMap['mode'] }}) <b>giving up retrying<b/>"
            lastTxMap['isModeSetReq'] = false    // giving up
            lastTxMap['setModeRetries'] = 0
        }
    }
    else {
        logDebug "modeReceiveCheck mode was changed OK to (${lastTxMap['mode']}). No need for further checks."
        lastTxMap.isModeSetReq = false    // setting mode was successfuly confimed, no need for further checks
        lastTxMap.setModeRetries = 0
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}


//
//  also, called every 1 minute from receiveCheck()
def setpointReceiveCheck() {
    if (settings?.resendFailed == false )
        return

    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isSetPointReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    Map lastRxMap = stringToJsonMap( state.lastRx )
    
    if (lastTxMap.setPoint != NOT_SET && ((lastTxMap.setPoint as String) != (lastRxMap.setPoint as String))) {
        lastTxMap.setPointRetries = lastTxMap.setPointRetries + 1
        if (lastTxMap.setPointRetries < MaxRetries) {
            logWarn "setpointReceiveCheck(${lastTxMap.setPoint}) <b>failed<b/> (last received is still ${lastRxMap.setPoint})"
            logDebug "resending setpoint command : ${lastTxMap.setPoint} (retry# ${lastTxMap.setPointRetries})"
            statsMap.txFailCtr = statsMap.txFailCtr + 1
            sendTuyaHeatingSetpoint(lastTxMap.setPoint)
        }
        else {
            logWarn "setpointReceiveCheck(${lastTxMap.setPoint}) <b>giving up retrying<b/>"
            lastTxMap.isSetPointReq = false
            lastTxMap.setPointRetries = 0
        }
    }
    else {
        logDebug "setpointReceiveCheck setPoint was changed successfuly to (${lastTxMap.setPoint}). No need for further checks."
        lastTxMap.setPoint = NOT_SET
        lastTxMap.isSetPointReq = false    
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}

//
// Brightness checking is also called every 1 minute from receiveCheck()
def setBrightnessReceiveCheck() {
    if (settings?.resendFailed == false )
        return

    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isSetBrightnessReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    Map lastRxMap = stringToJsonMap( state.lastRx )
    
    if (lastTxMap.setBrightness != NOT_SET && ((lastTxMap.setBrightness as String) != (lastRxMap.setBrightness as String))) {
        lastTxMap.setBrightnessRetries = (lastTxMap.setBrightnessRetries ?: 0) + 1
        if (lastTxMap.setBrightnessRetries < MaxRetries) {
            logWarn "setBrightnessReceiveCheck(${lastTxMap.setBrightness}) <b>failed<b/> (last received is still ${lastRxMap.setBrightness})"
            logDebug "resending setBrightness command : ${lastTxMap.setBrightness} (retry# ${lastTxMap.setBrightnessRetries})"
            statsMap.txFailCtr = statsMap.txFailCtr + 1
            setBrightness(lastTxMap.setBrightness)
        }
        else {
            logWarn "setBrightnessReceiveCheck(${lastTxMap.setPoint}) <b>giving up retrying<b/>"
            lastTxMap.isSetBrightnessReq = false
            lastTxMap.setBrightnessRetries = 0
        }
    }
    else {
        logDebug "setBrightnessReceiveCheck brightness was changed successfuly to (${lastTxMap.setBrightness}). No need for further checks."
        lastTxMap.setBrightness = NOT_SET
        lastTxMap.isSetBrightnessReq = false    
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}




//  receiveCheck() is unconditionally scheduled Every1Minute from installed() ..
def receiveCheck() {
    modeReceiveCheck()
    setpointReceiveCheck()
    setBrightnessReceiveCheck()
}

private sendTuyaCommand(dp, dp_type, fncmd, delay=200) {
    ArrayList<String> cmds = []
    cmds += zigbee.command(CLUSTER_TUYA, SETDATA, [:], delay, PACKET_ID + dp + dp_type + zigbee.convertToHexString((int)(fncmd.length()/2), 4) + fncmd )
    logDebug "sendTuyaCommand = ${cmds}"
    incTxCtr()
    return cmds
}

private wakeUpTuya() {
    sendZigbeeCommands(zigbee.readAttribute(0x0000, 0x0004, [:], delay=50) )
}

void sendZigbeeCommands(ArrayList<String> cmd) {
    if (settings?.logEnable) {log.debug "${device.displayName} sendZigbeeCommands(cmd=$cmd)"}
    hubitat.device.HubMultiAction allActions = new hubitat.device.HubMultiAction()
    cmd.each {
            allActions.add(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE))
    }
    incTxCtr()
    sendHubCommand(allActions)
}

private getPACKET_ID() {
    state.packetID = ((state.packetID ?: 0) + 1 ) % 65536
    return zigbee.convertToHexString(state.packetID, 4)
}

private getDescriptionText(msg) {
    def descriptionText = "${device.displayName} ${msg}"
    if (settings?.txtEnable) log.info "${descriptionText}"
    return descriptionText
}

def logsOff(){
    logInfo "debug logging is disabled"
    device.updateSetting("logEnable",[value:"false",type:"bool"])
}

// not used
def controlMode( mode ) {
    ArrayList<String> cmds = []
    
    switch (mode) {
        case "manual" : 
            cmds += sendTuyaCommand("02", DP_TYPE_ENUM, "00")// + sendTuyaCommand("03", DP_TYPE_ENUM, "01")    // iquix code
            logDebug "sending manual mode : ${cmds}"
            break
        case "program" :
            cmds += sendTuyaCommand("02", DP_TYPE_ENUM, "01")// + sendTuyaCommand("03", DP_TYPE_ENUM, "01")    // iquix code
            logDebug "sending program mode : ${cmds}"
            break
        default :
            break
    }
    sendZigbeeCommands( cmds )
}


def childLock( mode ) {
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) {dp = "09"}
    
    else {
        if (settings?.txtEnable) log.warn "${device.displayName} child lock mode: ${mode} is not supported for modelGroup${getModelGroup()}"
    }
    
    if (mode == "off") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "00")}
    else if (mode == "on") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "01")}
    else {logWarn "unsupported child lock mode ${mode} !"}
    //sendEvent(name: "childLock", value: mode) // I think the event should be sent when the confirmation is received from the device, and not before the command is sent.
    logInfo "sending child lock mode : ${mode}"
    sendZigbeeCommands( cmds )    
}

/*def windowOpenDetection( mode ) { -NOT IMPLEMENTED for AVATTO2
    ArrayList<String> cmds = []
    def dp
    //if (getModelGroup() in ["TRV07"]) {dp = "08"}
    //else {
        if (settings?.txtEnable) log.warn "${device.displayName} Window Open Detection mode: ${mode} is not supported or not implemented for modelGroup${getModelGroup()}"
    //}
    // TODO - check childLock for MOES
    if (mode == "off") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "00")}
    else if (mode == "on") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "01")}
    else {logWarn "unsupported Window Open Detection mode ${mode} !"}
    logInfo "sending Window Open Detectio mode : ${mode}"
    sendZigbeeCommands( cmds )    
}*/

def setBrightness( bri ) {
    ArrayList<String> cmds = []
    def dp
    if (isAVATTO2()) {
        dp = "6E"
        def key = brightnessOptions.find{it.value==bri}?.key
        logDebug "setBrightness ${bri} key=${key}"
        if (key != null) {
            def dpValHex = zigbee.convertToHexString(key as int, 2)
            cmds += sendTuyaCommand(dp, DP_TYPE_ENUM, dpValHex)            
            logDebug "changing brightness to ${bri} ($key)"
            // added 01/14/2023
            Map lastTxMap = stringToJsonMap( state.lastTx )
            lastTxMap.isSetBrightnessReq = true
            lastTxMap.setBrightness = bri
            state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
            runIn(3, setBrightnessReceiveCheck)
            sendZigbeeCommands( cmds )    
        }
        else {
            logWarn "invalid brightness control ${bri}"
        }
    }
    else {
        logWarn "brightness control is not supported for modelGroup ${getModelGroup()}"
    }
}

def setRelayState( mode ) {
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) {
        dp = "6F"
    logInfo "changing relay state to ${mode}"
    }
    else {
        if (settings?.txtEnable) log.warn "${device.displayName} relay state changing : ${mode} is not supported for modelGroup${getModelGroup()}"
    }
    
    if (mode == "NO") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "00")}
    else if (mode == "NC") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "01")}
    else {logWarn "unsupported relay state mode ${mode} !"}
    //sendEvent(name: "childLock", value: mode) // I think the event should be sent when the confirmation is received from the device, and not before the command is sent.
    logInfo "sending relay state mode : ${mode}"
    sendZigbeeCommands( cmds )    
}


def sensorSelection( sen ) {
    ArrayList<String> cmds = []
    def dp
    if (true) {
        dp = "2B"
        def key = sensorOptions.find{it.value == sen}?.key
        logDebug "sensorSelection ${sen} key=${key}"
        if (key != null) {
            def dpValHex = zigbee.convertToHexString(key as int, 2)
            cmds += sendTuyaCommand(dp, DP_TYPE_ENUM, dpValHex)            
            logDebug "changing sensor selection to ${sen} ($key)"
            sendZigbeeCommands( cmds )    
        }
        else {
            logWarn "invalid sensor selection ${sen}"
        }
    }
    else {
        logWarn "sensor selection is not supported for modelGroup ${getModelGroup()}"
    }
}

def calibration( offset ) {
    offset = 0
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) dp = "13"
    else return;
     // callibration command returns also thermostat mode (heat), operation mode (manual), heating stetpoint and few seconds later - the temperature!
    cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(offset as int, 8))
    sendEvent(name: "temperatureOffset", value: offset, unit: "\u00B0"+"C")
    logDebug "sending calibration offset : ${offset}"
    sendZigbeeCommands( cmds )    
}

Integer safeToInt(val, Integer defaultVal=0) {
    return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal
}

Double safeToDouble(val, Double defaultVal=0.0) {
    return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal
}

def getBatteryPercentageResult(rawValue) {
    //if (settings?.logEnable) log.debug "${device.displayName} Battery Percentage rawValue = ${rawValue} -> ${rawValue / 2}%"
    def result = [:]

    if (0 <= rawValue && rawValue <= 200) {
        result.name = 'battery'
        result.translatable = true
        result.value = Math.round(rawValue / 2)
        result.descriptionText = "${device.displayName} battery is ${result.value}%"
        result.isStateChange = true
        result.unit  = '%'
        sendEvent(result)
        if (settings?.txtEnable) log.info "${result.descriptionText}"
    }
    else {
        if (settings?.logEnable) log.warn "${device.displayName} ignoring BatteryPercentageResult(${rawValue})"
    }
}

def zTest( dpCommand, dpValue, dpTypeString ) {
    ArrayList<String> cmds = []
    def dpType   = dpTypeString=="DP_TYPE_VALUE" ? DP_TYPE_VALUE : dpTypeString=="DP_TYPE_BOOL" ? DP_TYPE_BOOL : dpTypeString=="DP_TYPE_ENUM" ? DP_TYPE_ENUM : null
    def dpValHex = dpTypeString=="DP_TYPE_VALUE" ? zigbee.convertToHexString(dpValue as int, 8) : dpValue

    log.warn " sending TEST command=${dpCommand} value=${dpValue} ($dpValHex) type=${dpType}"

    sendZigbeeCommands( sendTuyaCommand(dpCommand, dpType, dpValHex) )
}

def resetStats() {
    Map stats = [
        rxCtr : 0,
        txCtr : 0,
        dupeCtr : 0,
        txFailCtr : 0
    ]
    Map lastRx = [
        dp : NOT_SET,
        fncmd : NOT_SET,    // -1
        setPoint : NOT_SET,    // -1
        setBrightness : NOT_SET
    ]
    Map lastTx = [
        mode : "unknown",
        isModeSetReq : false,
        setModeRetries: 0,
        setPoint : NOT_SET,    // -1
        setPointRetries : 0,
        isSetPointReq : false,
        setBrightness : NOT_SET,    // -1
        setBrightnessRetries : 0,
        isSetBrightnessReq : false
    ]
    state.stats  =  mapToJsonString( stats )
    state.lastRx =  mapToJsonString( lastRx )
    state.lastTx =  mapToJsonString( lastTx )
    if (txtEnable==true) log.info "${device.displayName} Statistics were reset. Press F5 to refresh the device page"
}


String mapToJsonString( Map map) {
    if (map==null || map==[:]) return ""
    String str = JsonOutput.toJson(map)
    return str
}

Map stringToJsonMap( String str) {
    if (str==null) return [:]
    def jsonSlurper = new JsonSlurper()
    def map = jsonSlurper.parseText( str )
    return map
}

private incRxCtr() {
    try {
        Map statsMap = stringToJsonMap(state.stats)
        statsMap['rxCtr'] ++
        state.stats = mapToJsonString(statsMap)
    }
    catch (e) {
        if (settings?.logEnable) log.warn "${device.displayName} incRxCtr() exception"
    }
}

private incTxCtr()     { try {Map statsMap = stringToJsonMap(state.stats); statsMap['txCtr'] ++;     state.stats = mapToJsonString(statsMap) } catch (e) {statsMap['txCtr']=0} }
private incDupeCtr()   { try {Map statsMap = stringToJsonMap(state.stats); statsMap['dupeCtr'] ++;   state.stats = mapToJsonString(statsMap) } catch (e) {statsMap['dupeCtr']=0} }
private incTxFailCtr() { Map statsMap = stringToJsonMap(state.stats); try {statsMap['txFailCtr']++ } catch (e) {statsMap['txFailCtr']=0}; state.stats = mapToJsonString(statsMap)}

private setLastRx( int dp, int fncmd) {
    try {
        Map lastRxMap = stringToJsonMap(state.lastRx)
        lastRxMap['dp'] = dp
        lastRxMap['fncmd'] = fncmd
        state.lastRx = mapToJsonString(lastRxMap)
    }
    catch (e) {
        if (settings?.logEnable) log.warn "${device.displayName} setLastRx() exception"
    }
}

private setLastTx( String mode=null, Boolean isModeSetReq=null) {
    try {
        Map lastTxMap = stringToJsonMap(state.lastTx)
        if (mode != null) {
            lastTxMap['mode'] = mode
        }
        if (isModeSetReq != null) {
            lastTxMap['isModeSetReq'] = isModeSetReq
        }
        state.lastTx = mapToJsonString(lastTxMap)
    }
    catch (e) {
        if (settings?.logEnable) log.warn "${device.displayName} setLastTx() exception"
    }
}

def getLastMode() {
    try {    
        Map lastTx = stringToJsonMap( state.lastTx )
        return lastTx.mode
    }
    catch (e) {
        if (settings?.logEnable) log.warn "${device.displayName} getLastMode() exception"
        return "exception"
    }
}

def isDuplicated( int dp, int fncmd ) {
    Map oldDpFncmd = stringToJsonMap( state.lastRx )
    if (dp == oldDpFncmd.dp && fncmd == oldDpFncmd.fncmd)
        return true
    else
        return false
}

def logDebug(msg) {
    if (settings?.logEnable == null || settings?.logEnable == true) {
        log.debug "${device.displayName} " + msg
    }
}

def logInfo(msg) {
    if (settings?.txtEnable == null || settings?.txtEnable == true) {
        log.info "${device.displayName} " + msg
    }
}

def logWarn(msg) {
    if (settings?.logEnable == null || settings?.logEnable == true) {
        log.warn "${device.displayName} " + msg
    }
}

     
     
def test() {
    incRxCtr()
    def a = 5
}



