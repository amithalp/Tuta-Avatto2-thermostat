/**
 * amithalp -
 *    This driver is a stripped down version of @kkossev driver for Tuya wall themostats. The original driver did not support AVATTO2 model so I need to update the code.
 *    Things to do - 
 *              - Check why brighness become low after a few seconds even if you set it to high
 *              - invert relay option - what happens when doing factory reset and initializa - FACTORY RESET WILL CHANGE THE RELAY STATE TO NO. INITIALIZE WILL NOT CHANGE RELAY STATE



 *  Tuya Wall Thermostat driver for Hubitat Elevation - specific version for AVATTO2 model - TS0601, Manufacturer - _TZE204_lzriup1j

 *  https://community.hubitat.com/t/release-tuya-wall-mount-thermostat-water-electric-floor-heating-zigbee-driver/87050 
 *
 *    Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *    in compliance with the License. You may obtain a copy of the License at:
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *    on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *    for the specific language governing permissions and limitations under the License.
 * 
 *  Credits: @kkossev, Jaewon Park, iquix and many others
 * 
 * ver. 1.1.0 2024-04-18 	amithalp  - Inital stripped down version 
 * ver. 1.1.1 2024-01-19	amithalp  - Add frost protection and ForceManual functionality, set default thermostatFanMode=auto and some code cleaning
 * ver. 1.1.2 2024-01-19	amithalp  - Add support for changing fanMode from dashboard or device page in Hubitat

 *          Remarks by amithalp when working on this driver to make it fit the AVATTO2 (manufacturer: _TZE204_lzriup1j)
             tuyaDatapoints: [
                [1, 'system_mode', tuya.valueConverterBasic.lookup({'heat': true, 'off': false})],
                [2, 'current_heating_setpoint', tuya.valueConverter.divideBy10],
                [3, 'local_temperature', tuya.valueConverter.divideBy10],
                [4, 'preset', tuya.valueConverterBasic.lookup({'auto': tuya.enum(1), 'manual': tuya.enum(0), 'temporary_manual': tuya.enum(2)})],
                [9, 'child_lock', tuya.valueConverter.lockUnlock],
                [11, 'faultalarm', tuya.valueConverter.raw],
                [15, 'max_temperature_limit', tuya.valueConverter.divideBy10],
                [19, 'local_temperature_calibration', tuya.valueConverter.localTempCalibration3],
                [101, 'running_state', tuya.valueConverterBasic.lookup({'heat': tuya.enum(1), 'idle': tuya.enum(0)})],
                [102, 'frost_protection', tuya.valueConverter.onOff],
                [103, 'factory_reset', tuya.valueConverter.onOff],
                [104, 'working_day', tuya.valueConverter.workingDay],
                [107, 'deadzone_temperature', tuya.valueConverter.divideBy10],
                [109, null, tuya.valueConverter.ZWT198_schedule],
                [109, 'schedule_weekday', tuya.valueConverter.ZWT198_schedule],
                [109, 'schedule_holiday', tuya.valueConverter.ZWT198_schedule],
                [110, 'backlight_mode', tuya.valueConverter.backlightModeOffLowMediumHigh],
                [111, 'dp111', tuya.valueConverter.onOff],                      // this is for relay inversion from NC (1=normally close) to NO (0=normally open) not listed in Tuya, but device sends datapoint
                // ============== found but not functional datapoints:

                // [16, 'min_temperature_limit', tuya.valueConverter.divideBy10],  // datapoint listed in Tuya, but no communication from device
                // [105, 'dp105', tuya.valueConverter.onOff],                      // not listed in Tuya, but device sends datapoint
                

                // These are the schedule values in bytes, 8 periods in total (4 bytes per period).
                // For each period:
                // 1st byte: hour
                // 2nd byte: minute
                // 3rd, 4th bytes: temperature multiplied by 10
                // On the device last 2 periods are ignored if schedule_mode is 7day. When schedule_mode is disabled,
                // scheduling can't be configured at all on the device.
                // For example, if schedule_mode is weekday/sat+sun and this byte array is received:
                // [6,10,1,144,8,10,0,170,11,40,0,170,12,40,0,170,17,10,0,230,22,10,0,170,8,5,0,200,23,0,0,160]
                // Then the schedule is:
                // Mon-Fri: 6:10 --> 40C, 8:10 --> 17C, 11:40 --> 17C, 12:40 --> 17C, 17:10 --> 23C, 22:10 --> 17C
                // Sat-Sun: 8:05 --> 20C, 23:00 --> 16C
*/

def version() { "1.1.2" }
def timeStamp() {"19/01/2025 22:10"}

import groovy.json.*
import groovy.transform.Field
import hubitat.zigbee.zcl.DataType
import hubitat.device.HubAction
import hubitat.device.Protocol
import java.text.DecimalFormat
import groovy.time.TimeCategory


@Field static final Boolean _DEBUG = false

metadata {
    definition (name: "Tuya Wall Thermostat_AVATTO2_New_Version", namespace: "kkossev", author: "Krassimir Kossev", importUrl: "https://github.com/amithalp/Tuta-Avatto2-thermostat/blob/main/Tuya%20Wall%20Thermostat_AVATTO2_New_Version", singleThreaded: true ) {
        capability "Actuator"
        capability "Refresh"
        capability "Sensor"
        capability "Temperature Measurement"
        capability "Thermostat"
        capability "ThermostatHeatingSetpoint"
   //     capability "ThermostatCoolingSetpoint"
        capability "ThermostatOperatingState"
        capability "ThermostatSetpoint"
        capability "ThermostatMode"
        capability "Battery"
        capability "HealthCheck"
        
        attribute "childLock", "enum", ["off", "on"]
      //  attribute "windowOpenDetection", "enum", ["off", "on"]
        attribute "brightness", "enum", ['off', 'low', 'medium', 'high']
        attribute "healthStatus", "enum", ["offline", "online", "unknown"]
        attribute "sensorSelection", "enum", sensorOptions.values() as List<String>
        attribute "rtt", "number" 
        attribute "valve", "number" 
     //   attribute "windowOpen", "enum", ["false", "true"]
        attribute "minHeatingSetpoint", "number" 
        attribute "maxHeatingSetpoint", "number" 
        attribute "holidayModeSetpoint", "number" 
        attribute "temperatureOffset", "number"
        attribute "relayState", "enum", ["NO", "NC"]
        
        
        
        if (_DEBUG == true) {
            command "zTest", [
                [name:"dpCommand", type: "STRING", description: "Tuya DP Command", constraints: ["STRING"]],
                [name:"dpValue",   type: "STRING", description: "Tuya DP value", constraints: ["STRING"]],
                [name:"dpType",    type: "ENUM",   constraints: ["DP_TYPE_VALUE", "DP_TYPE_BOOL", "DP_TYPE_ENUM"], description: "DP data type"] 
            ]
            command "test"
        }
        command "initialize", [[name: "Initialize the thermostat after switching drivers.  \n\r   ***** Will load device default values! *****" ]]
        command "childLock",  [[name: "ChildLock", type: "ENUM", constraints: ["off", "on"], description: "Select Child Lock mode"] ]
        //command "windowOpenDetection",  [[name: "windowOpenDetection", type: "ENUM", constraints: ["off", "on"], description: "Select Window Open Detection mode"] ]
        command "setBrightness",  [[name: "setBrightness", type: "ENUM", constraints: ["off", "low", "medium", "high"], description: "Set LCD brightness"] ]
        command "setRelayState",  [[name: "setRelayState", type: "ENUM", constraints: ["NO", "NC"], description: "Set relay to act as NO or NC"] ]
        //command "sensorSelection",  [[name: "sensorSelection", type: "ENUM", constraints: ["99":"--- Select ---"] + sensorOptions, description: "Select the temperature sensor"] ]
        command "factoryReset", [[name:"factoryReset", type: "STRING", description: "Type 'YES'", constraints: ["STRING"]]]
        command "resetStats", [[name: "Reset Statistics" ]]
        
        (AVATTO2)
        fingerprint profileId:"0104", endpointId:"01", inClusters:"0000,0004,0005,EF00", outClusters:"0019,000A", model:"TS0601", manufacturer:"_TZE204_lzriup1j",  deviceJoinName: "AVATTO2 Wall Thermostat" // Amit 
    }
    preferences {
        if (logEnable == true || logEnable == false) { 
            input (name: "logEnable", type: "bool", title: "<b>Debug logging</b>", description: "<i>Debug information, useful for troubleshooting. Recommended value is <b>false</b></i>", defaultValue: false)
            input (name: "txtEnable", type: "bool", title: "<b>Description text logging</b>", description: "<i>Display measured values in HE log page. Recommended value is <b>true</b></i>", defaultValue: true)
            input (name: "forceManual", type: "bool", title: "<b>Force Manual Mode</b>", description: "<i>If the thermostat changes into schedule mode, then it automatically reverts back to manual mode</i>", defaultValue: false)
            input (name: "resendFailed", type: "bool", title: "<b>Resend failed commands</b>", description: "<i>If the thermostat does not change the Setpoint or Mode as expected, then commands will be resent automatically</i>", defaultValue: false)
            input (name: "minTemp", type: "number", title: "<b>Minimum Temperature</b>", description: "<i>The Minimum temperature setpoint that can be sent to the device</i>", defaultValue: 5, range: "0..60")
            input (name: "maxTemp", type: "number", title: "<b>Maximum Temperature</b>", description: "<i>The Maximum temperature setpoint that can be sent to the device</i>", defaultValue: 35, range: "15..95")
            input (name: "modelGroupPreference", title: "Select a model group. Recommended value is <b>'Auto detect'</b>", /*description: "<i>Thermostat type</i>",*/ type: "enum", options:["Auto detect":"Auto detect", "AVATTO2":"AVATTO2"], defaultValue: "Auto detect", required: false)        
            input (name: "tempCalibration", type: "decimal", title: "<b>Temperature Calibration</b>", description: "<i>Adjust measured temperature range: -9..9 C</i>", defaultValue: 0.0, range: "-9.0..9.0")
            
            if (getModelGroup() in ['AVATTO2'])  {
                input (name: "programMode", type: "enum", title: "<b>Program Mode</b> (thermostat internal schedule)", description: "<i>Recommended selection is '<b>off</b>'</i>", defaultValue: 0, options: [0:"off", 1:"Mon-Fri", 2:"Mon-Sat", 3: "Mon-Sun"])
            }
           
            input (name: "homeKitCompatibility",  type: "bool", title: "<b>HomeKit Compatibility</b>",  description: "Enable/disable HomeKit Compatibility", defaultValue: false)
            input (name: "PresetMode",  type: "enum", title: "<b>Preset Mode</b>",  description: "Auto or Manual", defaultValue: 0, options: [0:"manual", 1:"auto", 2:"temporary_manual"])
            input (name: 'frostProtection', type: 'bool', title: '<b>Disable/Enable frost protection</b>', description: '<i>Disable/Enable frost protection</i>', defaultValue: true)
        }
    }
}

@Field static final Map<String, String> Models = [
 //   '
    '_TZE204_lzriup1j'  : 'AVATTO2',      // Tuya AVATTO new Amit
 //   
]

def isAVATTO2()    { return device.getDataValue('manufacturer') in ['_TZE204_lzriup1j'] }

@Field static final Map brightnessOptions = [
    '0' : 'off',
    '1' : 'low',
    '2' : 'medium',
    '3' : 'high'
]


@Field static final Map faultOptions = [
    '0' : 'none',
    '1' : 'e1',
    '2' : 'e2',
    '3' : 'e3'
]

@Field static final Map sensorOptions = [   
    '0' : 'in',
    '1' : 'out',
    '2' : 'both'
]

@Field static final Map programModeOptions = [
    '0' : 'off',
    '1' : 'Mon-Fri',
    '2' : 'Mon-Sat',
    '3' : 'Mon-Sun'
]

@Field static final Integer presenceCountTreshold = 3
@Field static final Integer defaultPollingInterval = 3600
@Field static final Integer MAX_PING_MILISECONDS = 10000     // rtt more than 10 seconds will be ignored
@Field static final Integer COMMAND_TIMEOUT = 10             // timeout time in seconds
@Field static final Integer MaxRetries = 5
@Field static final Integer NOT_SET = -1
                                
private getCLUSTER_TUYA()       { 0xEF00 }
private getSETDATA()            { 0x00 }
private getSETTIME()            { 0x24 }

// Tuya Commands
private getTUYA_REQUEST()       { 0x00 }
private getTUYA_REPORTING()     { 0x01 }
private getTUYA_QUERY()         { 0x02 }
private getTUYA_STATUS_SEARCH() { 0x06 }
private getTUYA_TIME_SYNCHRONISATION() { 0x24 }

// tuya DP type
private getDP_TYPE_RAW()        { "01" }    // [ bytes ]
private getDP_TYPE_BOOL()       { "01" }    // [ 0/1 ]
private getDP_TYPE_VALUE()      { "02" }    // [ 4 byte value ]
private getDP_TYPE_STRING()     { "03" }    // [ N byte string ]
private getDP_TYPE_ENUM()       { "04" }    // [ 0-255 ]
private getDP_TYPE_BITMAP()     { "05" }    // [ 1,2,4 bytes ] as bits

//---------------------------- Parse incoming device messages to generate events --------------------------------------------------------------------------------------------------------------------------------------
def parse(String description) {
    checkDriverVersion()
    unschedule('deviceCommandTimeout')    
    incRxCtr()
    setHealthStatusOnline()    // was     setPresent()
    logDebug "parse() descMap = ${zigbee.parseDescriptionAsMap(description)}"
    if (description?.startsWith('catchall:') || description?.startsWith('read attr -')) {
        Map descMap = zigbee.parseDescriptionAsMap(description)
        if (descMap?.clusterInt == zigbee.BASIC_CLUSTER && descMap.attrInt == 0x01) {
            logDebug "Tuya check-in message (attribute ${descMap.attrId} reported: ${descMap.value})"
            def now = new Date().getTime()
            Map lastTxMap = stringToJsonMap( state.lastTx )
            def timeRunning = now.toInteger() - (lastTxMap.pingTime ?: '0').toInteger()
            if (timeRunning < MAX_PING_MILISECONDS) {
                sendRttEvent()
            } 
        }
        else if (descMap?.clusterInt==CLUSTER_TUYA && descMap?.command == "24") {        //getSETTIME
            logDebug "time synchronization request from device, descMap = ${descMap}"
            syncTuyaDateTime()
        } 
        else if (descMap?.clusterInt==CLUSTER_TUYA && descMap?.command == "0B") {    // ZCL Command Default Response
            String clusterCmd = descMap?.data[0]
            def status = descMap?.data[1]            
            logDebug "device has received Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data}"
            setLastRx( NOT_SET, NOT_SET)    // -1
            if (status != "00") {
                logWarn "ATTENTION! manufacturer = ${device.getDataValue("manufacturer")} group = ${getModelGroup()} unsupported Tuya cluster ZCL command 0x${clusterCmd} response 0x${status} data = ${descMap?.data} !!!"                
            }
            
        } 
        else if ((descMap?.clusterInt==CLUSTER_TUYA) && (descMap?.command == "01" || descMap?.command == "02")) {
            def transid = zigbee.convertHexToInt(descMap?.data[1])           // "transid" is just a "counter", a response will have the same transid as the command
            def dp = zigbee.convertHexToInt(descMap?.data[2])                // "dp" field describes the action/message of a command frame
            def dp_id = zigbee.convertHexToInt(descMap?.data[3])             // "dp_identifier" is device dependant
            def fncmd = getTuyaAttributeValue(descMap?.data)                 // 
            if (isDuplicated( dp, fncmd )) {
                logDebug "(duplicate) transid=${transid} dp_id=${dp_id} <b>dp=${dp}</b> fncmd=${fncmd} command=${descMap?.command} data = ${descMap?.data}" 
                //if ( state.duplicateCounter != null ) state.duplicateCounter = state.duplicateCounter +1
                incDupeCtr()
                return
            }
            else {
                logDebug "dp_id=${dp_id} <b>dp=${dp}</b> fncmdamithalp=${fncmd}"
                setLastRx( dp, fncmd)
            }
            
            //***************** START DEALING WITH DP VALUES *******************************************************************************************************************
            switch (dp) {
                case 0x01 :  // 'system_mode', tuya.valueConverterBasic.lookup({'heat': true, 'off': false})]
                    switch (getModelGroup()) {
                            case 'AVATTO2' :
                            def switchState = (fncmd == 0) ? "off" : "heat"
                            sendEvent(name: "thermostatMode", value: switchState)
                            if (switchState == "off") {
                                logInfo "switchState reported is: OFF"
                               // sendEvent(name: "thermostatOperatingState", value: "idle")
                            }
                            else {
                                logInfo "switchState reported is: ON and Mode is ${switchState} (dp=${dp}, fncmd=${fncmd})"
                                //sendEvent(name: "thermostatOperatingState", value: state.lastThermostatOperatingState)
                            }                        
                            //if (switchState == getLastMode())  {
                            //    logDebug "last sent mode ${getLastMode()} is confirmed from the device (dp=${dp}, fncmd=${fncmd})"
                            }
                            //else {
                            //    logWarn "last sent mode ${getLastMode()} DIFFERS from the mode received from the device ${switchState} (dp=${dp}, fncmd=${fncmd})"
                            //}
                            //break
                  
                        //default :
                         //   if (settings?.logEnable) {log.warn "${device.displayName} Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"}
                         //   break
                                       
                    break
                case 0x02 : // 'current_heating_setpoint', tuya.valueConverter.divideBy10]
                    switch (getModelGroup()) {
                      
                        case 'AVATTO2' :
                                          logDebug "-Received message dp=2 and fcmd is ${fncmd} - calling for process TuyaHeatSetpointReport with ${fncmd/10} value </b> "
                                          processTuyaHeatSetpointReport( fncmd/10 ) 
                        
                                    break
                     
                        default :
                            logWarn "Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"
                            break
                    }                   
                    break
                case 0x03 :    // 'local_temperature', tuya.valueConverter.divideBy10],
                    logDebug "processing command dp=${dp} fncmd=${fncmd} (lastThermostatMode=${state.lastThermostatMode})" 
                    switch (getModelGroup()) {
                            case 'AVATTO2' :    
                                logDebug "processTuyaTemperatureReport descMap?.size() = ${descMap?.data.size()} dp_id=${dp_id} <b>dp=${dp}</b> :"
                                processTuyaTemperatureReport( fncmd )
                            break
                            default :
                            logWarn "Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"
                            break
                    }
                    break
                        
                case 0x04: // Preset Mode
                    def currentPreset = device.currentValue("thermostatPreset")
                    if (fncmd == 0 && currentPreset == "manual" && settings?.forceManual == true) {
                        logDebug "parse() ignored redundant preset mode update (already in Manual mode)"
                        break // Exit without further processing
                    }

                    if (settings?.forceManual == true) {
                        logInfo "changes to Preset mode are rejected as forceManual is true. Reverting to Manual mode."
                        sendManualModeCommand()
                        break
                    }

                    // Process the reported mode if forceManual is false
                    def thermostatPresets = ["manual", "auto", "temporary_manual"]
                    def thermostatPreset = thermostatPresets[fncmd]
                    logDebug "preset mode is <b>${thermostatPreset}</b> (<b>dp=${dp}</b> fncmd=${fncmd})"
                    sendEvent(name: "thermostatPreset", value: thermostatPreset)
                    break


              
                case 0x09 :     // 'child_lock', tuya.valueConverter.lockUnlock]
                    if (getModelGroup() in ['AVATTO2']) {
                       def childLockState = (fncmd == 0) ? "off" : "on"
                        //logInfo "AVATTO2 Child lock dp=${dp} fncmd=${fncmd}" 
                        logInfo "Child lock reported ${childLockState}"    
                    sendEvent(name: "childLock", value: (fncmd == 0) ? "off" : "on" )
                    }
                    else {
                        logWarn "Thermostat model group ${getModelGroup()} is not processed! (dp=${dp}, fncmd=${fncmd})"
                    }    
                    break
                case 0x0B :          // [11, 'faultalarm', tuya.valueConverter.raw],  - Not yet implemented
                    break
                case 0x0F :    //  [15, 'max_temperature_limit', tuya.valueConverter.divideBy10]
                               // This parameter is set using menu item 9 on the thermostat menu "set upper themerature limit"  
                   if (getModelGroup() in ['AVATTO2']) {
                         device.updateSetting("maxTemp", [value: fncmd/10 as int , type:"number"]) // This parameter is set using menu item 9 on the thermostat menu "set upper themerature limit"
                         sendEvent(name: "maxHeatingSetpoint", value: fncmd/10)  
                       logInfo "Max Temp Limit is: ${fncmd/10} °C (dp=${dp}, fncmd=${fncmd})"
                            }
                    else {
                        logInfo "unknown dp=${dp} fncmd=${fncmd}"
                    }
                    break
              
                case 0x13 :   //  [19, 'local_temperature_calibration', tuya.valueConverter.localTempCalibration3]
                                // This parameter is set using menu item 1 on the thermostat menu "themerature compensation"
                    if (getModelGroup() in ['AVATTO2']) {
                        processTuyaCalibration( dp, fncmd )
                        logInfo "Calibration Offset is: ${fncmd/10} °C (dp=${dp}, fncmd=${fncmd})"
                    }
                    
                   break
              
                case 0x65 :    // [101, 'running_state', tuya.valueConverterBasic.lookup({'heat': tuya.enum(1), 'idle': tuya.enum(0)})]
                    if (getModelGroup() in ['AVATTO2']) {
                        def switchOperatingState = (fncmd == 1) ? "heating" : ((fncmd == 0) ? "idle" : null)
                        
                        logInfo "Thermostat Operating State is: ${switchOperatingState}"  
                        sendEvent(name: "thermostatOperatingState", value: (fncmd == 0) ? "idle" : "heating" )
                       
                        break    
                      }
                                        
                case 0x66 :     // [102, 'frost_protection', tuya.valueConverter.onOff]
                    if (getModelGroup() in ['AVATTO2']) {
                        logInfo "frost protection is: ${fncmd==0?'off':'on'} (0x${fncmd})"
                        device.updateSetting( 'frostProtection',  [value:(fncmd == 0) ? false : true, type:'bool'] )
                    break
                    }
                case 0x67 :    //  [103, 'factory_reset', tuya.valueConverter.onOff] 
                    if (getModelGroup() in ['AVATTO2']) {     // Factory Reset ?
                        def resetRequest = (fncmd == 0) ? "off" : "on"
                        if (resetRequest == "on") {
                                 logInfo "resetRequest is: ${resetRequest} and Factory Reset was performed"  
                        }
                        else {
                                logInfo "resetRequest is: ${resetRequest} and doing nothing"
                                     }
                       break 
                                                        }
                    else {
                        logInfo "unknown parameter is: ${fncmd} (dp=${dp}, fncmd=${fncmd}, data=${descMap?.data})"
                    }
                    break
                case 0x68 :    //  [104, 'working_day', tuya.valueConverter.workingDay]- NOT YET IMPLEMENTED
                    
                    break
               
                case 0x69 :     // (105) amithalp - not implemented
                    if (getModelGroup() in ['AVATTO2']) {
                        logInfo "AVATTO unknown parameter (105) is: ${fncmd}"                                                      
                    }
                    
                    break
                case 0x6B :     // [107, 'deadzone_temperature', tuya.valueConverter.divideBy10] - NOT YET IMPLEMETED
                    if (getModelGroup() in ['AVATTO2']) {
                        logInfo "AVATTO2 unknown parameter (107) is: ${fncmd}"                                                      
                    }
                   
                    break
               
                case 0x6C :    // (108)    - not implemented                                         
                    if (getModelGroup() in ['AVATTO2']) {  
                        logInfo "AVATTO2 unknown parameter (108) is: ${fncmd}"        
                    }
                
                    break
                
                case 0x6D :    // (109)   - NOT YET IMPLEMENTED                                              
                   if (getModelGroup() in ['AVATTO2']) {  
                        logInfo "AVATTO2 unknown parameter (109) is: ${fncmd}"        
                    }
                
                    break
                
                case 0x6E :       //  [110, 'backlight_mode', tuya.valueConverter.backlightModeOffLowMediumHigh]
                    if (getModelGroup() in ['AVATTO2']) { //set brightness for AVATTO2
                        logInfo "backplane brightness is ${brightnessOptions[fncmd.toString()]} (${fncmd})"
                        device.updateSetting( "brightness",  [value: fncmd.toString(), type:"enum"] )
                        Map lastRxMap = stringToJsonMap( state.lastRx )
                        lastRxMap.setBrightness = brightnessOptions[fncmd.toString()]
                        state.lastRx   = mapToJsonString( lastRxMap)
                        sendEvent(name: "brightness", value: brightnessOptions[fncmd.toString()])
                    }
                  
                    break
                
                 case 0x6F :       //  [111, 'relay mode', 0 is for NO and 1 for NC
                    switch (getModelGroup()) {
                            case 'AVATTO2' :
                            def relayState = (fncmd == 0) ? "NO" : "NC"
                            sendEvent(name: "relayState", value: relayState)
                            if (relayState == "NO") {
                                logInfo "relayState reported is: NO (normally open)"
                                sendEvent(name: "relayState", value: "NO")
                            }
                            else if (relayState == "NC") {
                                logInfo "relayState reported is: NC (normally close)"
                                sendEvent(name: "relayState", value: "NC")
                            }                        
                                   
                    break
                    }
            }
        }
             //  (dp) switch
        else if (descMap?.cluster == "0000") {
            logDebug "basic cluster report  : descMap = ${descMap}"
        } 
        else {
            logWarn "not parsed : "+descMap
        }
    } // if catchAll || readAttr
}
 //---------------------------------------------------- END OF PARSING METHOD -------------------------------------------------------------------------------------------------------------------------

def syncTuyaDateTime() {
    // The data format for time synchronization, including standard timestamps and local timestamps. Standard timestamp (4 bytes)    local timestamp (4 bytes) Time synchronization data format: The standard timestamp is the total number of seconds from 00:00:00 on January 01, 1970 GMT to the present.
    // For example, local timestamp = standard timestamp + number of seconds between standard time and local time (including time zone and daylight saving time).                 // Y2K = 946684800 
    def offset = 0
    def offsetHours = 0
    Calendar cal=Calendar.getInstance();    //it return same time as new Date()
    def hour = cal.get(Calendar.HOUR_OF_DAY)
    try {
        offset = location.getTimeZone().getOffset(new Date().getTime()) 
        offsetHours = (offset / 3600000) as int
        logDebug "timezone offset of current location is ${offset} (${offsetHours} hours), current hour is ${hour} h"
    } catch(e) {
        logError "cannot resolve current location. please set location in Hubitat location setting. Setting timezone offset to zero"
    }
    //
    def cmds
    cmds = zigbee.command(CLUSTER_TUYA, SETTIME, "0008" +zigbee.convertToHexString((int)(now()/1000),8) +  zigbee.convertToHexString((int)((now()+offset)/1000), 8))
    
    logDebug "sending time data : ${cmds}"
    cmds.each{ sendHubCommand(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE)) }
    incTxCtr()
    setLastRx( NOT_SET, NOT_SET)    // -1
}

def processTuyaHeatSetpointReport( fncmd ) 
//this method is called and used to receive the setpoint temperature from the thermostat and update the hubitat device attributes "heatingSetpoint" and "thermostatSetpoint"
{                        
    double setpointValue
    def model = getModelGroup()
    if (getModelGroup() in ['AVATTO2']) {  
            setpointValue = fncmd
    }
    else {
        setpointValue = fncmd 
    }
    setpointValue = setpointValue.round(1)
    logInfo "processTuyaHeatSetpointReport - setpointValue is: ${setpointValue}"+"\u00B0"+"C"
    //logInfo "${device.displayName} fncmd Value is: ${fncmd}"
    //logInfo "${device.displayName} processTuyaHeatSetpointReport - heatingSetpoint is: ${setpointValue}"+"\u00B0"+"C"
    sendEvent(name: "heatingSetpoint", value: setpointValue, unit: "\u00B0"+"C")
    sendEvent(name: "thermostatSetpoint", value: setpointValue, unit: "\u00B0"+"C")        // Google Home compatibility
    //
    Map lastRxMap = stringToJsonMap( state.lastRx )
    lastRxMap.setPoint = setpointValue
    state.lastRx   = mapToJsonString( lastRxMap)      // state.lastRx
}                        

def processTuyaTemperatureReport(fncmd) {
    if (getModelGroup() != 'AVATTO2') {
        logWarn "Model '${getModelGroup()}' is not supported by this method. Processing skipped."
        return
    }
	double currentTemperatureValue = fncmd / 10.0
    logInfo "Temperature is: ${currentTemperatureValue}" + "\u00B0" + "C"
    sendEvent(name: "temperature", value: currentTemperatureValue, unit: "\u00B0" + "C")
}


def processTuyaCalibration( dp, fncmd )
{
    def temp = fncmd/10 
    double doubleCalib = temp
    if (getModelGroup() in ['AVATTO2'] && dp == 19) { // 0x13
        device.updateSetting("tempCalibration", [value: temp , type:"decimal"])
        sendEvent(name: "temperatureOffset", value: temp, unit: "\u00B0"+"C")
        logDebug "calibration is: ${temp}"
    }
    
    else {
        logWarn "UNSUPPORTED temperature calibration for modelGroup=${getModelGroup()} : ${temp} (dp=${dp}, fncmd=${fncmd}) "
    }

    logInfo "temperature calibration (correction) is: ${doubleCalib} °C (dp=${dp}, fncmd=${fncmd}) "
}

def processPresets( dp, data ) {
    logDebug "processPresets fp-${dp} data=${data}"
    // 0x0401 # Mode (Received value 0:Manual / 1:Holiday / 2:Temporary Manual Mode / 3:Prog)
    // KK TODO - check why the difference for values 0 and 3 ?
    /*
    0x0401 :
    0 : Manual Mode
    1 : Holiday Mode
    2 : Temporary Manual Mode (will return to Schedule mode at the next schedule time)
    3 : Schedule Programming Mode


    TRV sends those values when changing modes:
    1 for Manual
    0 for Schedule
    2 for Temporary manual (in Schedule)
    3 for Away

    Schedule -> [0] for attribute 0x0401
    Manual -> [1] for attribute 0x0401
    Temp Manual -> [2] for attribute 0x0401
    Holiday -> [3] for attribute 0x0401

    */
    
    def mode
    def preset
    
    if (data == 0) { //namual
        mode = "heat"
        preset = "manual"
        }
    else if (data == 1) { //auto
        mode = "auto"
        preset = "auto"
    }
    else if (data == 2) { //temporary_manual
        mode = "heat"
        preset = "manual"
    }
    //temporary_manual
    //else if (data == 3) { //holiday
    //    mode = "off"
    //    preset = "holiday"
  //  }
    else {
        logWarn "processPresets unknown: ${data}"
        return;
    }
    /*if (state.lastThermostatMode == "emergency heat") {
        runIn(2, sendTuyaBoostModeOff)    // also turn boost off!
    }*/

    sendEvent(name: "thermostatMode", value: mode)    // mode was confirmed from the Preset info data...
    state.lastThermostatMode = mode
    
    // TODO - change tehrmostatPreset depending on preset ?
    logInfo "Presets: mode = ${mode} preset = ${preset}"
}

/* if this method is not used at all - DELETE
def processTuyaModes3(dp, data) {
    if (getModelGroup() != 'AVATTO2') {
        logWarn "processTuyaModes3: Unsupported model group '${getModelGroup()}'. Processing skipped."
        return
    }

    def mode
    switch (data) {
        case 0:
            mode = "auto" // schedule
            break
        case 1:
            mode = "heat" // manual
            break
        case 2:
            mode = "off" // away
            break
        default:
            logWarn "processTuyaModes3: Unknown mode received. dp=${dp}, data=${data}"
            return
    }

    logInfo "AVATTO2 mode is: ${mode}"
    sendEvent(name: "thermostatMode", value: mode)
}
*/

private int getTuyaAttributeValue(ArrayList _data) {
    int retValue = 0
    
    if (_data.size() >= 6) {
        int dataLength = _data[5] as Integer
        int power = 1;
        for (i in dataLength..1) {
            retValue = retValue + power * zigbee.convertHexToInt(_data[i+5])
            power = power * 256
        }
    }
    return retValue
}

def sendThermostatOperatingStateEvent( st ) {
    sendEvent(name: "thermostatOperatingState", value: st)
    state.lastThermostatOperatingState = st
}

def guessThermostatOperatingState() {
    try {
        double dTemp = Double.parseDouble(device.currentState('temperature').value)
        double dSet  = Double.parseDouble(device.currentState('heatingSetpoint').value)
 
        if (dTemp >= dSet) {
            logDebug "guessing operating state is IDLE"
            return "idle"
        }
        else {
            logDebug "guessing operating state is HEAT"
            return "heat"
        }
    }
    catch (NumberFormatException e) {
        return "unknown"
    }
}

// called from setThermostatMode( mode ) only
// TODO - refactor (switch by model) !
def sendTuyaThermostatMode(mode) {
    ArrayList<String> cmds = []
    def dp = ""
    def fn = ""
    def model = getModelGroup()

    if (model != 'AVATTO2') {
        logWarn "Model '${model}' is not supported by this function."
        return null
    }

    switch (mode) {
        case "off":
            // AVATTO2 'off' mode
            dp = "01"
            fn = "00"
            break

        case "heat":
            // AVATTO2 'heat' (manual) mode
            if (device.currentState('thermostatMode')?.value == "off") {
                cmds += switchThermostatOn()
            }
            dp = "01"
            fn = "01"
            break

        default:
            // For AVATTO2, any other mode is not supported
            logWarn "Unsupported mode '${mode}' for AVATTO2"
            return null
    }

    // Build and send the Tuya commands
    cmds += sendTuyaCommand(dp, mode == "off" ? DP_TYPE_BOOL : DP_TYPE_ENUM, fn)
    sendZigbeeCommands(cmds)
}


// called from heat() off() auto() ...
// sends TuyaCommand and checks after 4 seconds
def setThermostatMode( mode ) {
    logDebug "sending setThermostatMode(${mode})"
    setLastTx( mode=mode, isModeSetReq=true)
    //state.mode = mode
    runIn(4, modeReceiveCheck)
    sendTuyaThermostatMode( mode )
}



def sendTuyaHeatingSetpoint( temperature ) {
    logDebug "sendTuyaHeatingSetpoint(${temperature})"
    def settemp = temperature as int
    def dp = "10"
    def model = getModelGroup()
    switch (model) {
        case 'AVATTO2' :                          // AVATTO2 - only integer setPoints!
            dp = "02"
            settemp = temperature * 10
            break
        default :
            settemp = temperature
            break
    }    
    logDebug "changing setpoint to ${settemp}"
    //
    Map lastTxMap = stringToJsonMap( state.lastTx )
    lastTxMap.isSetPointReq = true
    lastTxMap.setPoint = temperature
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    //
    runIn(3, setpointReceiveCheck)
    sendZigbeeCommands( sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(settemp as int, 8)) )
}

def setThermostatSetpoint( temperature ) {
    setHeatingSetpoint( temperature )
}

//  ThermostatHeatingSetpoint command
//  sends TuyaCommand and checks after 4 seconds
//  1°C steps. (0.5°C setting on the TRV itself, rounded for zigbee interface)
def setHeatingSetpoint( temperature ) {
    def previousSetpoint = device.currentState('heatingSetpoint', true).value /*as int*/
    double tempDouble
    logDebug "setHeatingSetpoint temperature = ${temperature}  as int = ${temperature as int} (previousSetpointt = ${previousSetpoint})"
    if (settings?.maxTemp == null || settings?.minTemp == null ) { device.updateSetting("minTemp", [value: 5 , type:"number"]);  device.updateSetting("maxTemp", [value: 35 , type:"number"])   } // default is 10, so we should set 10 for consistency
    tempDouble = temperature
    
    if (tempDouble > settings?.maxTemp.value ) tempDouble = settings?.maxTemp.value
    if (tempDouble < settings?.minTemp.value ) tempDouble = settings?.minTemp.value
    tempDouble = tempDouble.round(1)
    sendEvent(name: "heatingSetpoint", value: tempDouble, unit: "\u00B0"+"C")
    sendEvent(name: "thermostatSetpoint", value: tempDouble, unit: "\u00B0"+"C")
    updateDataValue("lastRunningMode", "heat")
    
    state.heatingSetPointRetry = 0
    sendTuyaHeatingSetpoint( tempDouble )
}


/* def setCoolingSetpoint(temperature){
    if (settings?.logEnable) log.debug "${device.displayName} setCoolingSetpoint(${temperature}) called!"
    if (temperature != (temperature as int)) {
        temperature = (temperature + 0.5 ) as int
        logDebug "corrected temperature: ${temperature}"
    }
    sendEvent(name: "coolingSetpoint", value: temperature, unit: "\u00B0"+"C")
} */

def heat(){
    setThermostatMode("heat")
}

def off(){
    setThermostatMode("off")
}

def on() {
    heat()
}

def setThermostatFanMode(fanMode) { sendEvent(name: "thermostatFanMode", value: "${fanMode}", descriptionText: getDescriptionText("thermostatFanMode is ${fanMode}")) }

//def auto() { setThermostatMode("auto") }
//def emergencyHeat() { setThermostatMode("emergency heat") }
//def cool() { setThermostatMode("cool") }
//def fanAuto() { setThermostatFanMode("auto") }
//def fanCirculate() { setThermostatFanMode("circulate") }
//def fanOn() { setThermostatFanMode("on") }
def setSchedule(schedule) {
    logDebug "setSchedule(${schedule}) called!"
}

//---------------------------- KEEP MANUAL PRESET MODE WHEN FORCE MANUAL IS TRUE ----------------------------------------------------
def sendManualModeCommand() {
    if (state.cooldownActive == true) {
        logDebug "sendManualModeCommand() skipped: cooldown active"
        return // Exit if cooldown is active
    }

    logDebug "sendManualModeCommand() - sending Manual mode command"
    ArrayList<String> cmds = []
    cmds = sendTuyaCommand("04", DP_TYPE_ENUM, "00") // Set Preset Mode to Manual
    sendZigbeeCommands(cmds)

    state.cooldownActive = true
    runIn(5, resetCooldown) // Reset cooldown after 5 seconds
}

def resetCooldown() {
    state.cooldownActive = false
    logDebug "resetCooldown() - ready to send Manual mode command again"
}
//---------------------------- END OF KEEP MANUAL PRESET MODE WHEN FORCE MANUAL IS TRUE ----------------------------------------------------

def switchThermostatOn() {
    logInfo "switching On!"
    ArrayList<String> cmds = []
    cmds = sendTuyaCommand("01", DP_TYPE_BOOL, "01", delay=2750)    // increased delay to 2750 on 1/27/2022
    return cmds
}


/**
 * Returns the model group of the device based on its manufacturer.
 * If modelGroupPreference is set to "Auto detect", it will try to match the manufacturer with a known model group.
 * If no match is found, it will return "UNKNOWN".
 * If modelGroupPreference is set to a specific model group, it will return that model group.
 * @return The model group of the device.
 */
def getModelGroup() {
    def manufacturer = device.getDataValue("manufacturer")
    def modelGroup = 'UNKNOWN'
    if (modelGroupPreference == null) {
        device.updateSetting("modelGroupPreference", "Auto detect")
    }
    if (modelGroupPreference == "Auto detect") {
        if (manufacturer in Models) {
            modelGroup = Models[manufacturer]
        }
        else {
             modelGroup = 'UNKNOWN'
        }
    }
    else {
         modelGroup = modelGroupPreference 
    }
    //logDebug "${device.displayName} manufacturer ${manufacturer} group is ${modelGroup}"
    return modelGroup
}

def sendSupportedThermostatModes() {
    def supportedThermostatModes = []
    if (getModelGroup() == 'AVATTO2') {
        supportedThermostatModes = ["off", "heat"]
    } else {
        logWarn "Model '${getModelGroup()}' is not supported by this function."
        return
    }
    sendEvent(name: "supportedThermostatModes", value: JsonOutput.toJson(supportedThermostatModes), isStateChange: true)
}

def sendSupportedThermostatOperatingModes() {
    def supportedThermostatOperatingModes = []
    switch (getModelGroup()) {
        case 'AVATTO2' :
            supportedThermostatOperatingModes = ["idle", "heat"]
            break
       }    
    sendEvent(name: "supportedThermostatOperatingModes", value:  JsonOutput.toJson(supportedThermostatOperatingModes), isStateChange: true)
}

//------------------------------------------- BASIC METHODS --------------------------------------------------------------------------------------------
def installed() {
//  called from initialize()
    logInfo "installed()"
    
    //sendEvent(name: "supportedThermostatFanModes", value: JsonOutput.toJson(["auto", "circulate", "on"]), isStateChange: true)    
    sendSupportedThermostatModes()
    sendEvent(name: "thermostatMode", value: "heat", isStateChange: true)
    //sendEvent(name: "thermostatFanMode", value: "auto", isStateChange: true)
    state.lastThermostatMode = "heat"
    sendThermostatOperatingStateEvent( "idle" )
    sendEvent(name: "thermostatOperatingState", value: "idle", isStateChange: true)
    sendEvent(name: "thermostatSetpoint", value:  20.0, unit: "\u00B0"+"C", isStateChange: true)        // Google Home compatibility
    sendEvent(name: "thermostatFanMode", value: "auto", isStateChange: true) //thermostatFanMode is not supported but we assign the 'auto' value for dashboard appearance
    sendEvent(name: "heatingSetpoint", value: 24.0, unit: "\u00B0"+"C", isStateChange: true)
    //sendEvent(name: "coolingSetpoint", value: 30.0, unit: "\u00B0"+"C", isStateChange: true)
    sendEvent(name: "temperature", value: 22.0, unit: "\u00B0"+"C", isStateChange: true)    
    updateDataValue("lastRunningMode", "heat")    

    //state.setpoint = 0
    unschedule()
    runEvery1Minute(receiveCheck)    // KK: check
}

def updated() {
    ArrayList<String> cmds = []
    if (settings?.modelGroupPreference == null) {
        device.updateSetting("modelGroupPreference", [value: "Auto detect", type: "enum"])
        state.deviceProfile = "AUTO_DETECT"
    }

    if (settings?.modelGroupPreference != null) {
        logDebug "current state.deviceProfile=${state.deviceProfile}, settings.modelGroupPreference=${settings?.modelGroupPreference}, getModelGroup()=${getModelGroup()}"
        if (settings?.modelGroupPreference != state.deviceProfile) {
            logWarn "Changing the device profile from ${state.deviceProfile} to ${settings?.modelGroupPreference}"
            state.deviceProfile = settings?.modelGroupPreference
            initializeVars(fullInit = false)
            logInfo "Press F5 to refresh the page"
        }
    } else {
        logDebug "modelGroupPreference is not set"
    }

    log.info "Updating ${device.getLabel()} (${device.getName()}) model ${device.getDataValue('model')} manufacturer <b>${device.getDataValue('manufacturer')}</b> modelGroupPreference = <b>${settings?.modelGroupPreference}</b> (${getModelGroup()})"
    logInfo "Force manual is <b>${forceManual}</b>; Resend failed is <b>${resendFailed}</b>"
    logInfo "Debug logging is <b>${logEnable}</b>; Description text logging is <b>${txtEnable}</b>"

    if (logEnable == true) {
        runIn(86400, logsOff, [overwrite: true, misfire: "ignore"]) // Turn off debug logging after 24 hours
    } else {
        unschedule(logsOff)
    }
    runIn(defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])

    // tempCalibration for AVATTO2
    if (getModelGroup() == 'AVATTO2') {
        def dp = "13"
        if (dp != null) {
            logDebug "tempCalibration = ${tempCalibration}"
            def fncmd = (safeToDouble(tempCalibration) * 10) as int
            logDebug "tempCalibration fncmd = ${fncmd}"
            cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(fncmd as int, 8))
        }

        // maxTemp for AVATTO2
        dp = "0F"
        if (dp != null) {
            def fncmd = safeToInt(maxTemp)
            logDebug "Setting maxTemp to ${fncmd * 10}"
            cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(fncmd * 10 as int, 8))
        }

        // programMode for AVATTO2
        if (settings?.programMode != null) {
            def value = safeToInt(programMode)
            logDebug "Setting Program Mode to ${programModeOptions[value.toString()]} (${programMode})"
            cmds += sendTuyaCommand("68", DP_TYPE_ENUM, zigbee.convertToHexString(value as int, 2))
        }

        // frostProtection for AVATTO2
        def fncmd = settings?.frostProtection == false ? 0 : 1
        logInfo "Setting frost protection to ${fncmd} (${fncmd == 0 ? 'off' : 'on'})"
        cmds += sendTuyaCommand("66", DP_TYPE_BOOL, zigbee.convertToHexString(fncmd as int, 2))

        // brightness for AVATTO2
        logInfo "settings?.brightness = ${settings?.brightness}"
        if (settings?.brightness != null) {
            def key = safeToInt(settings?.brightness)
            def value = brightnessOptions[key.toString()]
            if (value != null) {
                def dpValHex = zigbee.convertToHexString(key as int, 2)
                cmds += sendTuyaCommand("6E", DP_TYPE_ENUM, dpValHex)
                logDebug "Setting brightness to ${value} ($key)"
            }
        }
    } else {
        logWarn "Model '${getModelGroup()}' is not supported by this function."
        return
    }

    if (cmds.size() > 0) {
        logInfo "Update finished"
        logDebug "cmds = ${cmds}"
        sendZigbeeCommands(cmds)
    } else {
        logDebug "Nothing to update"
    }
}

def refresh() {
//called from refresh at the device page
    ArrayList<String> cmds = []
    def model = getModelGroup()
    def fncmd
    logInfo "refresh() ${model}..."
    switch (model) {
       case 'AVATTO2' :  // wakes up AVATTO - LCD display goes to normal brightness
            fncmd = 0
            cmds += sendTuyaCommand("27", DP_TYPE_ENUM, zigbee.convertToHexString(fncmd as int, 8))
            break
        default :
            cmds += zigbee.readAttribute(0 , 0 )
            break
    }
    sendZigbeeCommands( cmds ) 
}

def configure() {
    initialize()
}

def initialize() {
    if (true) "${device.displayName} Initialize()..."
    unschedule()
    initializeVars()
    runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
    setDeviceLimits()
    installed()
    updated()
    runIn( 3, logInitializeRezults)
}
//-------------------------------------------END OF BASIC METHODS ---------------------------------------------------------------------------------------------

def factoryReset( yes ) {
    ArrayList<String> cmds = []
    def model = getModelGroup()    
    if (yes != "YES") {
        logWarn "type '<b>YES</b>' to confirm ${model} factory resetting!"
        return
    }

    def fncmd
    logWarn "FACTORY RESET ${model}..."
    switch (model) {
        case 'AVATTO2' :
            fncmd = 1    // reset!
            cmds += sendTuyaCommand("67", DP_TYPE_BOOL, zigbee.convertToHexString(fncmd as int, 2))
            logInfo "FACTORY RESETING ${model}..."
            break
        default :
            cmds += zigbee.readAttribute(0 , 0 )
            break
    }
    sendZigbeeCommands( cmds )     
}


def driverVersionAndTimeStamp() {version()+' '+timeStamp()}

/**
 * Checks if the driver version has changed and updates the settings if necessary.
 * If the driver version has changed, the method initializes the variables, removes deprecated state variables,
 * and resets the statistics. Finally, it updates the driver version in the state.
 */
def checkDriverVersion() {
    if (state.driverVersion == null || driverVersionAndTimeStamp() != state.driverVersion) {
        logInfo "updating the settings from the current driver version ${state.driverVersion} to the new version ${driverVersionAndTimeStamp()}"
        initializeVars( fullInit = false ) 
        if (device.currentValue("presence", true) != null) {
            device.deleteCurrentState("presence")                // removed from version 1.3.0
        }
        if (state.rxCounter != null) state.remove("rxCounter")
        if (state.txCounter != null) state.remove("txCounter")
        if (state.old_dp != null)    state.remove("old_dp")
        if (state.old_fncmd != null) state.remove("old_fncmd")
        if (state.setpoint != null)  state.remove("setpoint")
        if (state.modeSetRetry != null)  state.remove("modeSetRetry")
        if (state.heatingSetPointRetry != null)  state.remove("heatingSetPointRetry")
        //
        if (state.lastRx == null || state.stats == null || state.lastTx == null) {
            resetStats()
        }
        state.driverVersion = driverVersionAndTimeStamp()
    }
}

def setPresent() { setHealthStatusOnline() }    // trap for backward compatibility versions prior 1.3.0
def pollPresence() { deviceHealthCheck() }      // trap for backward compatibility versions prior 1.3.0

// 
/**
 * Called when any event was received from the Zigbee device in parse() method..
 * Sets the health status of the device to "online" if it is not already set to "online".
 * Sends a health status event and logs that the device is now online.
 * Schedules a device health check to run after the default polling interval.
 */
def setHealthStatusOnline() {
    if (!((device.currentValue('healthStatus') ?: 'unknown') in ['online']))  {
        sendHealthStatusEvent('online')
        logInfo "is now online!"
        runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
    }
    state.notPresentCounter = 0
}


/**
 * called every 60 minutes
 * Checks the health status of the device and sends an event if it is offline.
 * 
 * @return none
 */
def deviceHealthCheck() {
    if (state.notPresentCounter != null) {
        state.notPresentCounter = state.notPresentCounter + 1
        if (state.notPresentCounter >= presenceCountTreshold) {
            if ((device.currentValue("healthStatus") ?: 'unknown') != 'offline' ) {
                logWarn "not present!"
                sendHealthStatusEvent('offline')
            }
        }
    }
    else {
        state.notPresentCounter = 0  
    }
    runIn( defaultPollingInterval, deviceHealthCheck, [overwrite: true, misfire: "ignore"])
}

void sendHealthStatusEvent(value) {
    def descriptionText = "healthStatus changed to ${value}"
    sendEvent(name: "healthStatus", value: value, descriptionText: descriptionText, isStateChange: true, isDigital: true)
    if (value == 'online') {
        logInfo "${descriptionText}"
    }
    else {
        logWarn "<b>${descriptionText}</b>" 
    }
}

def ping() {
    logInfo 'ping...'
    scheduleCommandTimeoutCheck()
    Map lastTxMap = stringToJsonMap(state.lastTx)
    lastTxMap.pingTime = new Date().getTime()
    sendZigbeeCommands( zigbee.readAttribute(zigbee.BASIC_CLUSTER, 0x01, [:], 0) )
    state.lastTx = mapToJsonString( lastTxMap )
}

private void scheduleCommandTimeoutCheck(int delay = COMMAND_TIMEOUT) {
    runIn(delay, 'deviceCommandTimeout')
}

void deviceCommandTimeout() {
    logWarn 'no response received (sleepy device or offline?)'
    sendRttEvent("timeout")
}

void sendRttEvent( String value=null) {
    def now = new Date().getTime()
    Map lastTxMap = stringToJsonMap( state.lastTx )
    def timeRunning = now.toInteger() - (lastTxMap.pingTime ?: now).toInteger()
    def descriptionText = "Round-trip time is ${timeRunning} (ms)"
    if (value == null) {
        logInfo "${descriptionText}"
        sendEvent(name: "rtt", value: timeRunning, descriptionText: descriptionText, unit: "ms", isDigital: true)    
    }
    else {
        descriptionText = "Round-trip time is ${value}"
        logInfo "${descriptionText}"
        sendEvent(name: "rtt", value: value, descriptionText: descriptionText, isDigital: true)    
    }
}


def logInitializeRezults() {
    logInfo "manufacturer  = ${device.getDataValue("manufacturer")} ModelGroup = ${getModelGroup()}"
    logInfo "Initialization finished\r                          version=${version()} (Timestamp: ${timeStamp()})"
}

void initializeVars( boolean fullInit = true ) {
    if (settings?.txtEnable) log.info "${device.displayName} InitializeVars()... fullInit = ${fullInit}"
    if (fullInit == true ) {
        state.clear()
        resetStats()
        state.driverVersion = driverVersionAndTimeStamp()
    }
    if (device.currentValue('healthStatus') == null) sendHealthStatusEvent('unknown')    
    //
    setLastRx( NOT_SET, NOT_SET)    // -1
    state.packetID = 0
    //
    if (fullInit == true || state.lastThermostatMode == null) state.lastThermostatMode = "unknown"
    if (fullInit == true || state.lastThermostatOperatingState == null) state.lastThermostatOperatingState = "unknown"
    if (fullInit == true || state.notPresentCounter == null) state.notPresentCounter = 0
    //
    if (fullInit == true || settings?.logEnable == null) device.updateSetting("logEnable", true)
    if (fullInit == true || settings?.txtEnable == null) device.updateSetting("txtEnable", true)
    if (fullInit == true || settings?.forceManual == null) device.updateSetting("forceManual", false)    
    if (fullInit == true || settings?.resendFailed == null) device.updateSetting("resendFailed", false)    
   // if (fullInit == true || settings?.minTemp == null) device.updateSetting("minTemp", [value: 5 , type:"number"])    
    if (fullInit == true || settings?.maxTemp == null) device.updateSetting("maxTemp", [value: 35 , type:"number"])
    if (fullInit == true || settings?.tempCeiling == null) device.updateSetting("tempCeiling", [value: 35 , type:"number"])
    if (fullInit == true || settings?.tempCalibration == null) device.updateSetting("tempCalibration", [value:0.0, type:"decimal"])
   // if (fullInit == true || settings?.hysteresis == null) device.updateSetting("hysteresis", [value:1.0, type:"decimal"])
    //if (fullInit == true || settings?.sound == null) device.updateSetting("sound", true)    
    if (fullInit == true || settings?.frostProtection == null) device.updateSetting("frostProtection", true)    
    if (fullInit == true || settings?.brightness == null) device.updateSetting("brightness", [value:"3", type:"enum"])
    if (fullInit == true || settings?.homeKitCompatibility == null) device.updateSetting("homeKitCompatibility", true)    
    
    //
}

def setDeviceLimits() { // for google and amazon compatability
    sendEvent(name:"minHeatingSetpoint", value: settings.minTemp ?: 5, unit: "°C", isStateChange: true)
    sendEvent(name:"maxHeatingSetpoint", value: settings.maxTemp ?: 35, unit: "°C", isStateChange: true)
    updateDataValue("lastRunningMode", "heat")
    logInfo "setDeviceLimits - device max/min set"
}    

// scheduled for call from setThermostatMode() 4 seconds after the mode was potentiually changed.
// also, called every 1 minute from receiveCheck()
def modeReceiveCheck() {
    if (settings?.resendFailed == false )
        return
    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isModeSetReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    
    if (lastTxMap.mode != device.currentState('thermostatMode', true).value) {
        lastTxMap['setModeRetries'] = lastTxMap['setModeRetries'] + 1
        logWarn "modeReceiveCheck() <b>failed</b> (expected ${lastTxMap['mode']}, current ${device.currentState('thermostatMode', true).value}), retry#${lastTxMap['setModeRetries']}"
        if (lastTxMap['setModeRetries'] < MaxRetries) {
            logDebug "resending mode command : ${lastTxMap['mode']}"
            statsMap['txFailCtr'] = statsMap['txFailCtr'] + 1
            setThermostatMode( lastTxMap['mode'] )
        }
        else {
            logWarn "modeReceiveCheck(${lastTxMap['mode'] }}) <b>giving up retrying<b/>"
            lastTxMap['isModeSetReq'] = false    // giving up
            lastTxMap['setModeRetries'] = 0
        }
    }
    else {
        logDebug "modeReceiveCheck mode was changed OK to (${lastTxMap['mode']}). No need for further checks."
        lastTxMap.isModeSetReq = false    // setting mode was successfuly confimed, no need for further checks
        lastTxMap.setModeRetries = 0
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}


//
//  also, called every 1 minute from receiveCheck()
def setpointReceiveCheck() {
    if (settings?.resendFailed == false )
        return

    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isSetPointReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    Map lastRxMap = stringToJsonMap( state.lastRx )
    
    if (lastTxMap.setPoint != NOT_SET && ((lastTxMap.setPoint as String) != (lastRxMap.setPoint as String))) {
        lastTxMap.setPointRetries = lastTxMap.setPointRetries + 1
        if (lastTxMap.setPointRetries < MaxRetries) {
            logWarn "setpointReceiveCheck(${lastTxMap.setPoint}) <b>failed<b/> (last received is still ${lastRxMap.setPoint})"
            logDebug "resending setpoint command : ${lastTxMap.setPoint} (retry# ${lastTxMap.setPointRetries})"
            statsMap.txFailCtr = statsMap.txFailCtr + 1
            sendTuyaHeatingSetpoint(lastTxMap.setPoint)
        }
        else {
            logWarn "setpointReceiveCheck(${lastTxMap.setPoint}) <b>giving up retrying<b/>"
            lastTxMap.isSetPointReq = false
            lastTxMap.setPointRetries = 0
        }
    }
    else {
        logDebug "setpointReceiveCheck setPoint was changed successfuly to (${lastTxMap.setPoint}). No need for further checks."
        lastTxMap.setPoint = NOT_SET
        lastTxMap.isSetPointReq = false    
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}

//
// Brightness checking is also called every 1 minute from receiveCheck()
def setBrightnessReceiveCheck() {
    if (settings?.resendFailed == false )
        return

    Map lastTxMap = stringToJsonMap( state.lastTx )
    if (lastTxMap.isSetBrightnessReq == false)
        return
    Map statsMap = stringToJsonMap( state.stats )
    Map lastRxMap = stringToJsonMap( state.lastRx )
    
    if (lastTxMap.setBrightness != NOT_SET && ((lastTxMap.setBrightness as String) != (lastRxMap.setBrightness as String))) {
        lastTxMap.setBrightnessRetries = (lastTxMap.setBrightnessRetries ?: 0) + 1
        if (lastTxMap.setBrightnessRetries < MaxRetries) {
            logWarn "setBrightnessReceiveCheck(${lastTxMap.setBrightness}) <b>failed<b/> (last received is still ${lastRxMap.setBrightness})"
            logDebug "resending setBrightness command : ${lastTxMap.setBrightness} (retry# ${lastTxMap.setBrightnessRetries})"
            statsMap.txFailCtr = statsMap.txFailCtr + 1
            setBrightness(lastTxMap.setBrightness)
        }
        else {
            logWarn "setBrightnessReceiveCheck(${lastTxMap.setPoint}) <b>giving up retrying<b/>"
            lastTxMap.isSetBrightnessReq = false
            lastTxMap.setBrightnessRetries = 0
        }
    }
    else {
        logDebug "setBrightnessReceiveCheck brightness was changed successfuly to (${lastTxMap.setBrightness}). No need for further checks."
        lastTxMap.setBrightness = NOT_SET
        lastTxMap.isSetBrightnessReq = false    
    }
    state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
    state.stats  = mapToJsonString( statsMap)      // save everything back to state.stats
}




//  receiveCheck() is unconditionally scheduled Every1Minute from installed() ..
def receiveCheck() {
    modeReceiveCheck()
    setpointReceiveCheck()
    setBrightnessReceiveCheck()
}

private sendTuyaCommand(dp, dp_type, fncmd, delay=200) {
    ArrayList<String> cmds = []
    cmds += zigbee.command(CLUSTER_TUYA, SETDATA, [:], delay, PACKET_ID + dp + dp_type + zigbee.convertToHexString((int)(fncmd.length()/2), 4) + fncmd )
    logDebug "sendTuyaCommand = ${cmds}"
    incTxCtr()
    return cmds
}

private wakeUpTuya() {
    sendZigbeeCommands(zigbee.readAttribute(0x0000, 0x0004, [:], delay=50) )
}

void sendZigbeeCommands(ArrayList<String> cmd) {
    logDebug "sendZigbeeCommands(cmd=$cmd)"
    hubitat.device.HubMultiAction allActions = new hubitat.device.HubMultiAction()
    cmd.each {
            allActions.add(new hubitat.device.HubAction(it, hubitat.device.Protocol.ZIGBEE))
    }
    incTxCtr()
    sendHubCommand(allActions)
}

private getPACKET_ID() {
    state.packetID = ((state.packetID ?: 0) + 1 ) % 65536
    return zigbee.convertToHexString(state.packetID, 4)
}

private getDescriptionText(msg) {
    def descriptionText = "${device.displayName} ${msg}"
    logInfo "${descriptionText}"
    return descriptionText
}

def logsOff(){
    logInfo "debug logging is disabled"
    device.updateSetting("logEnable",[value:"false",type:"bool"])
}

// not used
def controlMode( mode ) {
    ArrayList<String> cmds = []
    
    switch (mode) {
        case "manual" : 
            cmds += sendTuyaCommand("02", DP_TYPE_ENUM, "00")// + sendTuyaCommand("03", DP_TYPE_ENUM, "01")    // iquix code
            logDebug "sending manual mode : ${cmds}"
            break
        case "program" :
            cmds += sendTuyaCommand("02", DP_TYPE_ENUM, "01")// + sendTuyaCommand("03", DP_TYPE_ENUM, "01")    // iquix code
            logDebug "sending program mode : ${cmds}"
            break
        default :
            break
    }
    sendZigbeeCommands( cmds )
}


def childLock( mode ) {
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) {dp = "09"}
    
    else {
        logWarn "child lock mode: ${mode} is not supported for modelGroup${getModelGroup()}"
    }
    
    if (mode == "off") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "00")}
    else if (mode == "on") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "01")}
    else {logWarn "unsupported child lock mode ${mode} !"}
    //sendEvent(name: "childLock", value: mode) // I think the event should be sent when the confirmation is received from the device, and not before the command is sent.
    logInfo "sending child lock mode : ${mode}"
    sendZigbeeCommands( cmds )    
}

/*def windowOpenDetection( mode ) { -NOT IMPLEMENTED for AVATTO2
		}*/


def setBrightness( bri ) {
    ArrayList<String> cmds = []
    def dp
    if (isAVATTO2()) {
        dp = "6E"
        def key = brightnessOptions.find{it.value==bri}?.key
        logDebug "setBrightness ${bri} key=${key}"
        if (key != null) {
            def dpValHex = zigbee.convertToHexString(key as int, 2)
            cmds += sendTuyaCommand(dp, DP_TYPE_ENUM, dpValHex)            
            logDebug "changing brightness to ${bri} ($key)"
            // added 01/14/2023
            Map lastTxMap = stringToJsonMap( state.lastTx )
            lastTxMap.isSetBrightnessReq = true
            lastTxMap.setBrightness = bri
            state.lastTx = mapToJsonString( lastTxMap )    // save everything back to state.lastTx
            runIn(3, setBrightnessReceiveCheck)
            sendZigbeeCommands( cmds )    
        }
        else {
            logWarn "invalid brightness control ${bri}"
        }
    }
    else {
        logWarn "brightness control is not supported for modelGroup ${getModelGroup()}"
    }
}

def setRelayState( mode ) {
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) {
        dp = "6F"
    logInfo "changing relay state to ${mode}"
    }
    else {
        logWarn "relay state changing : ${mode} is not supported for modelGroup${getModelGroup()}"
    }
    
    if (mode == "NO") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "00")}
    else if (mode == "NC") {cmds += sendTuyaCommand(dp, DP_TYPE_BOOL, "01")}
    else {logWarn "unsupported relay state mode ${mode} !"}
    //sendEvent(name: "childLock", value: mode) // I think the event should be sent when the confirmation is received from the device, and not before the command is sent.
    logInfo "sending relay state mode : ${mode}"
    sendZigbeeCommands( cmds )    
}

def sensorSelection( sen ) {
    ArrayList<String> cmds = []
    def dp
    if (true) {
        dp = "2B"
        def key = sensorOptions.find{it.value == sen}?.key
        logDebug "sensorSelection ${sen} key=${key}"
        if (key != null) {
            def dpValHex = zigbee.convertToHexString(key as int, 2)
            cmds += sendTuyaCommand(dp, DP_TYPE_ENUM, dpValHex)            
            logDebug "changing sensor selection to ${sen} ($key)"
            sendZigbeeCommands( cmds )    
        }
        else {
            logWarn "invalid sensor selection ${sen}"
        }
    }
    else {
        logWarn "sensor selection is not supported for modelGroup ${getModelGroup()}"
    }
}

def calibration( offset ) {
    offset = 0
    ArrayList<String> cmds = []
    def dp
    if (getModelGroup() in ["AVATTO2"]) dp = "13"
    else return;
     // callibration command returns also thermostat mode (heat), operation mode (manual), heating stetpoint and few seconds later - the temperature!
    cmds += sendTuyaCommand(dp, DP_TYPE_VALUE, zigbee.convertToHexString(offset as int, 8))
    sendEvent(name: "temperatureOffset", value: offset, unit: "\u00B0"+"C")
    logDebug "sending calibration offset : ${offset}"
    sendZigbeeCommands( cmds )    
}

Integer safeToInt(val, Integer defaultVal=0) {
    return "${val}"?.isInteger() ? "${val}".toInteger() : defaultVal
}

Double safeToDouble(val, Double defaultVal=0.0) {
    return "${val}"?.isDouble() ? "${val}".toDouble() : defaultVal
}

def getBatteryPercentageResult(rawValue) {
    //if (settings?.logEnable) log.debug "${device.displayName} Battery Percentage rawValue = ${rawValue} -> ${rawValue / 2}%"
    def result = [:]

    if (0 <= rawValue && rawValue <= 200) {
        result.name = 'battery'
        result.translatable = true
        result.value = Math.round(rawValue / 2)
        result.descriptionText = "${device.displayName} battery is ${result.value}%"
        result.isStateChange = true
        result.unit  = '%'
        sendEvent(result)
        logInfo "${result.descriptionText}"
    }
    else {
        logWwarn "ignoring BatteryPercentageResult(${rawValue})"
    }
}

def zTest( dpCommand, dpValue, dpTypeString ) {
    ArrayList<String> cmds = []
    def dpType   = dpTypeString=="DP_TYPE_VALUE" ? DP_TYPE_VALUE : dpTypeString=="DP_TYPE_BOOL" ? DP_TYPE_BOOL : dpTypeString=="DP_TYPE_ENUM" ? DP_TYPE_ENUM : null
    def dpValHex = dpTypeString=="DP_TYPE_VALUE" ? zigbee.convertToHexString(dpValue as int, 8) : dpValue

    logWarn " sending TEST command=${dpCommand} value=${dpValue} ($dpValHex) type=${dpType}"

    sendZigbeeCommands( sendTuyaCommand(dpCommand, dpType, dpValHex) )
}

def resetStats() {
    Map stats = [
        rxCtr : 0,
        txCtr : 0,
        dupeCtr : 0,
        txFailCtr : 0
    ]
    Map lastRx = [
        dp : NOT_SET,
        fncmd : NOT_SET,    // -1
        setPoint : NOT_SET,    // -1
        setBrightness : NOT_SET
    ]
    Map lastTx = [
        mode : "unknown",
        isModeSetReq : false,
        setModeRetries: 0,
        setPoint : NOT_SET,    // -1
        setPointRetries : 0,
        isSetPointReq : false,
        setBrightness : NOT_SET,    // -1
        setBrightnessRetries : 0,
        isSetBrightnessReq : false
    ]
    state.stats  =  mapToJsonString( stats )
    state.lastRx =  mapToJsonString( lastRx )
    state.lastTx =  mapToJsonString( lastTx )
    logInfo "Statistics were reset. Press F5 to refresh the device page"
}


String mapToJsonString( Map map) {
    if (map==null || map==[:]) return ""
    String str = JsonOutput.toJson(map)
    return str
}

Map stringToJsonMap( String str) {
    if (str==null) return [:]
    def jsonSlurper = new JsonSlurper()
    def map = jsonSlurper.parseText( str )
    return map
}

private incRxCtr() {
    try {
        Map statsMap = stringToJsonMap(state.stats)
        statsMap['rxCtr'] ++
        state.stats = mapToJsonString(statsMap)
    }
    catch (e) {
        logWarn "incRxCtr() exception"
    }
}

private incTxCtr()     { try {Map statsMap = stringToJsonMap(state.stats); statsMap['txCtr'] ++;     state.stats = mapToJsonString(statsMap) } catch (e) {statsMap['txCtr']=0} }
private incDupeCtr()   { try {Map statsMap = stringToJsonMap(state.stats); statsMap['dupeCtr'] ++;   state.stats = mapToJsonString(statsMap) } catch (e) {statsMap['dupeCtr']=0} }
private incTxFailCtr() { Map statsMap = stringToJsonMap(state.stats); try {statsMap['txFailCtr']++ } catch (e) {statsMap['txFailCtr']=0}; state.stats = mapToJsonString(statsMap)}

private setLastRx( int dp, int fncmd) {
    try {
        Map lastRxMap = stringToJsonMap(state.lastRx)
        lastRxMap['dp'] = dp
        lastRxMap['fncmd'] = fncmd
        state.lastRx = mapToJsonString(lastRxMap)
    }
    catch (e) {
        logWarn "setLastRx() exception"
    }
}

private setLastTx( String mode=null, Boolean isModeSetReq=null) {
    try {
        Map lastTxMap = stringToJsonMap(state.lastTx)
        if (mode != null) {
            lastTxMap['mode'] = mode
        }
        if (isModeSetReq != null) {
            lastTxMap['isModeSetReq'] = isModeSetReq
        }
        state.lastTx = mapToJsonString(lastTxMap)
    }
    catch (e) {
        logWarn "setLastTx() exception"
    }
}

def getLastMode() {
    try {    
        Map lastTx = stringToJsonMap( state.lastTx )
        return lastTx.mode
    }
    catch (e) {
        logWarn "getLastMode() exception"
        return "exception"
    }
}

def isDuplicated( int dp, int fncmd ) {
    Map oldDpFncmd = stringToJsonMap( state.lastRx )
    if (dp == oldDpFncmd.dp && fncmd == oldDpFncmd.fncmd)
        return true
    else
        return false
}

//-------------------------------- LOGGING METHODS ----------------------------------------------------------
def logDebug(msg) {
    if (settings?.logEnable) log.debug "${device.displayName} ${msg}"
}

def logWarn(msg) {
    if (settings?.txtEnable) log.warn "${device.displayName} ${msg}"
}

def logInfo(msg) {
    if (settings?.txtEnable) log.info "${device.displayName} ${msg}"
}
//----------------------------END OF LOGGING METHODS ------------------------------------------------------------

def test() {
    incRxCtr()
    def a = 5
}



